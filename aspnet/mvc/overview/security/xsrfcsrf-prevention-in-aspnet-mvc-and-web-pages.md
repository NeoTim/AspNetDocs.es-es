---
uid: mvc/overview/security/xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages
title: Prevención de XSRF/CSRF en ASP.NET MVC y Web pages | Microsoft Docs
author: Rick-Anderson
description: La falsificación de solicitudes entre sitios (también conocida como XSRF o CSRF) es un ataque contra aplicaciones hospedadas en Web, por lo que un sitio Web malintencionado puede influir en la interacción...
ms.author: riande
ms.date: 03/14/2013
ms.assetid: aadc5fa4-8215-4fc7-afd5-bcd2ef879728
msc.legacyurl: /mvc/overview/security/xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages
msc.type: authoredcontent
ms.openlocfilehash: 6fcfcda5b95e5844f7d357ac0cbb6d1fd2e215ac
ms.sourcegitcommit: 84b1681d4e6253e30468c8df8a09fe03beea9309
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 11/02/2019
ms.locfileid: "73445776"
---
# <a name="xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages"></a><span data-ttu-id="3c418-103">Prevención de XSRF/CSRF en ASP.NET MVC y Web Pages</span><span class="sxs-lookup"><span data-stu-id="3c418-103">XSRF/CSRF Prevention in ASP.NET MVC and Web Pages</span></span>

<span data-ttu-id="3c418-104">por [Rick Anderson]((https://twitter.com/RickAndMSFT))</span><span class="sxs-lookup"><span data-stu-id="3c418-104">by [Rick Anderson]((https://twitter.com/RickAndMSFT))</span></span>

> <span data-ttu-id="3c418-105">La falsificación de solicitudes entre sitios (también conocida como XSRF o CSRF) es un ataque contra aplicaciones hospedadas en Web, por lo que un sitio Web malintencionado puede influir en la interacción entre un explorador cliente y un sitio web de confianza para ese explorador.</span><span class="sxs-lookup"><span data-stu-id="3c418-105">Cross-site request forgery (also known as XSRF or CSRF) is an attack against web-hosted applications whereby a malicious web site can influence the interaction between a client browser and a web site trusted by that browser.</span></span> <span data-ttu-id="3c418-106">Estos ataques son posibles porque los exploradores Web enviarán tokens de autenticación automáticamente con cada solicitud a un sitio Web.</span><span class="sxs-lookup"><span data-stu-id="3c418-106">These attacks are made possible because web browsers will send authentication tokens automatically with every request to a web site.</span></span> <span data-ttu-id="3c418-107">El ejemplo canónico es una cookie de autenticación, como ASP. Vale de autenticación de formularios de la red.</span><span class="sxs-lookup"><span data-stu-id="3c418-107">The canonical example is an authentication cookie, such as ASP.NET's Forms Authentication ticket.</span></span> <span data-ttu-id="3c418-108">Sin embargo, los sitios web que utilizan cualquier mecanismo de autenticación persistente (como la autenticación de Windows, básica, etc.) pueden ser objeto de estos ataques.</span><span class="sxs-lookup"><span data-stu-id="3c418-108">However, web sites which use any persistent authentication mechanism (such as Windows Authentication, Basic, and so forth) can be targeted by these attacks.</span></span>
> 
> <span data-ttu-id="3c418-109">Un ataque de XSRF es distinto de un ataque de suplantación de identidad (phishing).</span><span class="sxs-lookup"><span data-stu-id="3c418-109">An XSRF attack is distinct from a phishing attack.</span></span> <span data-ttu-id="3c418-110">Los ataques de suplantación de identidad requieren la interacción de la víctima.</span><span class="sxs-lookup"><span data-stu-id="3c418-110">Phishing attacks require interaction from the victim.</span></span> <span data-ttu-id="3c418-111">En un ataque de suplantación de identidad (phishing), un sitio Web malintencionado imitará el sitio web de destino y se le engañará a proporcionar información confidencial al atacante.</span><span class="sxs-lookup"><span data-stu-id="3c418-111">In a phishing attack, a malicious web site will mimic the target web site, and the victim is fooled into providing sensitive information to the attacker.</span></span> <span data-ttu-id="3c418-112">En un ataque XSRF, a menudo no hay ninguna interacción necesaria para el sujeto.</span><span class="sxs-lookup"><span data-stu-id="3c418-112">In an XSRF attack, there is often no interaction necessary from the victim.</span></span> <span data-ttu-id="3c418-113">En su lugar, el atacante confía en el explorador enviando automáticamente todas las cookies pertinentes al sitio web de destino.</span><span class="sxs-lookup"><span data-stu-id="3c418-113">Rather, the attacker is relying on the browser automatically sending all relevant cookies to the destination web site.</span></span>
> 
> <span data-ttu-id="3c418-114">Para obtener más información, vea el [proyecto Open Web Application Security Project](https://www.owasp.org/index.php/Main_Page)(OWASP) [XSRF](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)).</span><span class="sxs-lookup"><span data-stu-id="3c418-114">For more information, see the [Open Web Application Security Project](https://www.owasp.org/index.php/Main_Page)(OWASP) [XSRF](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)).</span></span>

## <a name="anatomy-of-an-attack"></a><span data-ttu-id="3c418-115">Anatomía de un ataque</span><span class="sxs-lookup"><span data-stu-id="3c418-115">Anatomy of an attack</span></span>

<span data-ttu-id="3c418-116">Para recorrer un ataque de XSRF, considere la posibilidad de que un usuario desee realizar algunas transacciones bancarias en línea.</span><span class="sxs-lookup"><span data-stu-id="3c418-116">To walk through an XSRF attack, consider a user who wants to perform some online banking transactions.</span></span> <span data-ttu-id="3c418-117">Este usuario visita por primera vez WoodgroveBank.com e inicia sesión, momento en el que el encabezado de respuesta contendrá su cookie de autenticación:</span><span class="sxs-lookup"><span data-stu-id="3c418-117">This user first visits WoodgroveBank.com and logs in, at which point the response header will contain her authentication cookie:</span></span>

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample1.cmd)]

<span data-ttu-id="3c418-118">Dado que la cookie de autenticación es una cookie de sesión, el explorador la borrará automáticamente cuando se cierre el proceso del explorador.</span><span class="sxs-lookup"><span data-stu-id="3c418-118">Because the authentication cookie is a session cookie, it will be automatically cleared by the browser when the browser process exits.</span></span> <span data-ttu-id="3c418-119">Sin embargo, hasta ese momento, el explorador incluirá automáticamente la cookie con cada solicitud en WoodgroveBank.com.</span><span class="sxs-lookup"><span data-stu-id="3c418-119">However, until that time, the browser will automatically include the cookie with each request to WoodgroveBank.com.</span></span> <span data-ttu-id="3c418-120">El usuario ahora quiere transferir $1000 a otra cuenta, por lo que rellena un formulario en el sitio de banca y el explorador realiza esta solicitud al servidor:</span><span class="sxs-lookup"><span data-stu-id="3c418-120">The user now wants to transfer $1000 to another account, so she fills out a form on the banking site, and the browser makes this request to the server:</span></span>

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample2.cmd)]

<span data-ttu-id="3c418-121">Dado que esta operación tiene un efecto secundario (inicia una transacción monetaria), el sitio de banca ha elegido requerir una solicitud HTTP POST para iniciar esta operación.</span><span class="sxs-lookup"><span data-stu-id="3c418-121">Because this operation has a side effect (it initiates a monetary transaction), the banking site has chosen to require an HTTP POST in order to initiate this operation.</span></span> <span data-ttu-id="3c418-122">El servidor lee el token de autenticación de la solicitud, busca el número de cuenta del usuario actual, comprueba que existen fondos suficientes y, a continuación, inicia la transacción en la cuenta de destino.</span><span class="sxs-lookup"><span data-stu-id="3c418-122">The server reads the authentication token from the request, looks up the current user's account number, verifies that sufficient funds exist, and then initiates the transaction into the destination account.</span></span>

<span data-ttu-id="3c418-123">Su banca en línea se completa, el usuario navega fuera del sitio de banca y visita otras ubicaciones en la Web.</span><span class="sxs-lookup"><span data-stu-id="3c418-123">Her online banking complete, the user navigates away from the banking site and visits other locations on the web.</span></span> <span data-ttu-id="3c418-124">Uno de esos sitios: fabrikam.com: incluye el marcado siguiente en una página insertada dentro de un &lt;iframe&gt;:</span><span class="sxs-lookup"><span data-stu-id="3c418-124">One of those sites – fabrikam.com – includes the following markup on a page embedded within an &lt;iframe&gt;:</span></span>

[!code-html[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample3.html)]

<span data-ttu-id="3c418-125">Esto hace que el explorador realice esta solicitud:</span><span class="sxs-lookup"><span data-stu-id="3c418-125">Which then causes the browser to make this request:</span></span>

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample4.cmd)]

<span data-ttu-id="3c418-126">El atacante está aprovechando el hecho de que el usuario todavía puede tener un token de autenticación válido para el sitio web de destino y usa un pequeño fragmento de código de JavaScript para hacer que el explorador realice automáticamente una solicitud HTTP POST al sitio de destino.</span><span class="sxs-lookup"><span data-stu-id="3c418-126">The attacker is exploiting the fact that the user might still have a valid authentication token for the target web site, and she is using a small snippet of Javascript to cause the browser to make an HTTP POST to the target site automatically.</span></span> <span data-ttu-id="3c418-127">Si el token de autenticación sigue siendo válido, el sitio de banca iniciará una transferencia de $250 a la cuenta del que elija el atacante.</span><span class="sxs-lookup"><span data-stu-id="3c418-127">If the authentication token is still valid, the banking site will initiate a transfer of $250 into the account of the attacker's choosing.</span></span>

### <a name="ineffective-mitigations"></a><span data-ttu-id="3c418-128">Mitigaciones ineficaces</span><span class="sxs-lookup"><span data-stu-id="3c418-128">Ineffective mitigations</span></span>

<span data-ttu-id="3c418-129">Es interesante tener en cuenta que en el escenario anterior, el hecho de que WoodgroveBank.com se accediera a través de SSL y tenía una cookie de autenticación solo de SSL era insuficiente para frustrar el ataque.</span><span class="sxs-lookup"><span data-stu-id="3c418-129">It is interesting to note that in the above scenario, the fact that WoodgroveBank.com was being accessed via SSL and had an SSL-only authentication cookie was insufficient to thwart the attack.</span></span> <span data-ttu-id="3c418-130">El atacante puede especificar el esquema de [URI](http://en.wikipedia.org/wiki/URI_scheme) (https) en su &lt;formulario&gt; elemento y el explorador seguirá enviando cookies no caducadas al sitio de destino siempre y cuando dichas cookies sean coherentes con el esquema de URI del destino previsto.</span><span class="sxs-lookup"><span data-stu-id="3c418-130">The attacker is able to specify the [URI scheme](http://en.wikipedia.org/wiki/URI_scheme) (https) in her &lt;form&gt; element, and the browser will continue to send unexpired cookies to the target site as long as those cookies are consistent with the URI scheme of the intended target.</span></span>

<span data-ttu-id="3c418-131">Se puede argumentar que el usuario simplemente no debe visitar sitios que no son de confianza, ya que solo los sitios de confianza pueden estar seguros en línea.</span><span class="sxs-lookup"><span data-stu-id="3c418-131">One could argue that the user should simply not visit untrusted sites, as visiting only trusted sites is helps to remain safe online.</span></span> <span data-ttu-id="3c418-132">Esto es cierto, pero desgraciadamente este Consejo no siempre es práctico.</span><span class="sxs-lookup"><span data-stu-id="3c418-132">There is some truth to this, but unfortunately this advice is not always practical.</span></span> <span data-ttu-id="3c418-133">Quizás el usuario "confíe" en el sitio de noticias local ConsolidatedMessenger.</span><span class="sxs-lookup"><span data-stu-id="3c418-133">Perhaps the user "trusts" the local news site ConsolidatedMessenger.</span></span> <span data-ttu-id="3c418-134">ConsolidatedMessenger.com y va a visitar ese sitio en su lugar, pero ese sitio tiene una vulnerabilidad de XSS que permite a un atacante insertar el mismo fragmento de código que se estaba ejecutando en fabrikam.com.</span><span class="sxs-lookup"><span data-stu-id="3c418-134">ConsolidatedMessenger.com and goes to visit that site instead, but that site has an XSS vulnerability which allows an attacker to inject the same snippet of code that was running on fabrikam.com.</span></span>

<span data-ttu-id="3c418-135">Puede comprobar que las solicitudes entrantes tienen un [encabezado de referencia](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) que hace referencia a su dominio.</span><span class="sxs-lookup"><span data-stu-id="3c418-135">You can verify that incoming requests have a [Referer header](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) referencing your domain.</span></span> <span data-ttu-id="3c418-136">Esto detendrá las solicitudes que se envían involuntariamente desde un dominio de terceros.</span><span class="sxs-lookup"><span data-stu-id="3c418-136">This will stop requests unwittingly submitted from a third-party domain.</span></span> <span data-ttu-id="3c418-137">Sin embargo, algunas personas deshabilitan el encabezado de referencia del explorador por motivos de privacidad y, a veces, los atacantes pueden suplantar ese encabezado si el sujeto tiene instalado cierto software no seguro.</span><span class="sxs-lookup"><span data-stu-id="3c418-137">However, some people disable their browser's Referer header for privacy reasons, and attackers can sometimes spoof that header if the victim has certain insecure software installed.</span></span> <span data-ttu-id="3c418-138">La comprobación del [encabezado de referencia](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) no se considera un enfoque seguro para evitar ataques de XSRF.</span><span class="sxs-lookup"><span data-stu-id="3c418-138">Verifying the [Referer header](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) is not considered a secure approach to preventing XSRF attacks.</span></span>

## <a name="web-stack-runtime-xsrf-mitigations"></a><span data-ttu-id="3c418-139">Mitigaciones de XSRF en tiempo de ejecución de pila Web</span><span class="sxs-lookup"><span data-stu-id="3c418-139">Web Stack Runtime XSRF mitigations</span></span>

<span data-ttu-id="3c418-140">El tiempo de ejecución de la pila Web de ASP.NET utiliza una variante del [patrón de token del sincronizador](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#synchronizer-token-pattern) para defenderse frente a ataques de XSRF.</span><span class="sxs-lookup"><span data-stu-id="3c418-140">The ASP.NET Web Stack Runtime uses a variant of the [synchronizer token pattern](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#synchronizer-token-pattern) to defend against XSRF attacks.</span></span> <span data-ttu-id="3c418-141">La forma general del patrón de token del sincronizador es que se envían dos tokens antixsrf al servidor con cada HTTP POST (además del token de autenticación): un token como una cookie y el otro como valor de formulario.</span><span class="sxs-lookup"><span data-stu-id="3c418-141">The general form of the synchronizer token pattern is that two anti-XSRF tokens are submitted to the server with each HTTP POST (In addition to the authentication token): one token as a cookie, and the other as a form value.</span></span> <span data-ttu-id="3c418-142">Los valores de token generados por el tiempo de ejecución de ASP.NET no son deterministas o predecibles por un atacante.</span><span class="sxs-lookup"><span data-stu-id="3c418-142">The token values generated by the ASP.NET runtime are not deterministic or predictable by an attacker.</span></span> <span data-ttu-id="3c418-143">Cuando se envían los tokens, el servidor permitirá que la solicitud continúe solo si ambos tokens pasan una comprobación de comparación.</span><span class="sxs-lookup"><span data-stu-id="3c418-143">When the tokens are submitted, the server will allow the request to proceed only if both tokens pass a comparison check.</span></span>

<span data-ttu-id="3c418-144">El token de la *sesión* de comprobación de solicitudes de XSRF se almacena como una cookie HTTP y actualmente contiene la siguiente información en su carga:</span><span class="sxs-lookup"><span data-stu-id="3c418-144">The XSRF request verification *session token* is stored as an HTTP cookie and currently contains the following information in its payload:</span></span>

- <span data-ttu-id="3c418-145">Un token de seguridad, que consta de un identificador aleatorio de 128 bits.</span><span class="sxs-lookup"><span data-stu-id="3c418-145">A security token, consisting of a random 128-bit identifier.</span></span>   
 <span data-ttu-id="3c418-146">En la imagen siguiente se muestra el token de sesión de comprobación de solicitud de XSRF mostrado con las herramientas de desarrollo F12 de Internet Explorer: (tenga en cuenta que esta es la implementación actual y está sujeta, incluso probablemente, para cambiar).</span><span class="sxs-lookup"><span data-stu-id="3c418-146">The following image shows the XSRF request verification session token displayed with the Internet Explorer F12 developer tools: (Note this is the current implementation and is subject, even likely, to change.)</span></span>

![](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/_static/image1.png)

<span data-ttu-id="3c418-147">El *token de campo* se almacena como un `<input type="hidden" />` y contiene la siguiente información en su carga:</span><span class="sxs-lookup"><span data-stu-id="3c418-147">The *field token* is stored as an `<input type="hidden" />` and contains the following information in its payload:</span></span>

- <span data-ttu-id="3c418-148">El nombre de usuario del usuario que ha iniciado sesión (si está autenticado).</span><span class="sxs-lookup"><span data-stu-id="3c418-148">The logged-in user's username (if authenticated).</span></span>
- <span data-ttu-id="3c418-149">Los datos adicionales proporcionados por un [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx).</span><span class="sxs-lookup"><span data-stu-id="3c418-149">Any additional data provided by an [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx).</span></span>

<span data-ttu-id="3c418-150">Las cargas de los tokens anti-XSRF se cifran y firman, por lo que no se puede ver el nombre de usuario al usar las herramientas de para examinar los tokens.</span><span class="sxs-lookup"><span data-stu-id="3c418-150">The payloads of the anti-XSRF tokens are encrypted and signed, so you can't view the username when using tools to examine the tokens.</span></span> <span data-ttu-id="3c418-151">Cuando la aplicación web está destinada a ASP.NET 4,0, los servicios criptográficos se proporcionan mediante la rutina [MachineKey. encode](https://msdn.microsoft.com/library/system.web.security.machinekey.encode.aspx) .</span><span class="sxs-lookup"><span data-stu-id="3c418-151">When the web application is targeting ASP.NET 4.0, cryptographic services are provided by the [MachineKey.Encode](https://msdn.microsoft.com/library/system.web.security.machinekey.encode.aspx) routine.</span></span> <span data-ttu-id="3c418-152">Cuando la aplicación web está destinada a ASP.NET 4,5 o posterior, los servicios criptográficos se proporcionan mediante la rutina [MachineKey. Protect](https://msdn.microsoft.com/library/system.web.security.machinekey.protect(v=vs.110)) , que ofrece un mejor rendimiento, extensibilidad y seguridad.</span><span class="sxs-lookup"><span data-stu-id="3c418-152">When the web application is targeting ASP.NET 4.5 or higher, cryptographic services are provided by the [MachineKey.Protect](https://msdn.microsoft.com/library/system.web.security.machinekey.protect(v=vs.110)) routine, which offers better performance, extensibility, and security.</span></span> <span data-ttu-id="3c418-153">Consulte las siguientes entradas de blog para obtener más detalles:</span><span class="sxs-lookup"><span data-stu-id="3c418-153">See the following blog posts for more details:</span></span>

- [<span data-ttu-id="3c418-154">Mejoras criptográficas en ASP.NET 4,5, PT. 1</span><span class="sxs-lookup"><span data-stu-id="3c418-154">Cryptographic Improvements in ASP.NET 4.5, pt. 1</span></span>](https://blogs.msdn.com/b/webdev/archive/2012/10/22/cryptographic-improvements-in-asp-net-4-5-pt-1.aspx)
- [<span data-ttu-id="3c418-155">Mejoras criptográficas en ASP.NET 4,5, PT. 2</span><span class="sxs-lookup"><span data-stu-id="3c418-155">Cryptographic Improvements in ASP.NET 4.5, pt. 2</span></span>](https://blogs.msdn.com/b/webdev/archive/2012/10/23/cryptographic-improvements-in-asp-net-4-5-pt-2.aspx)
- [<span data-ttu-id="3c418-156">Mejoras criptográficas en ASP.NET 4,5, PT. 3</span><span class="sxs-lookup"><span data-stu-id="3c418-156">Cryptographic Improvements in ASP.NET 4.5, pt. 3</span></span>](https://blogs.msdn.com/b/webdev/archive/2012/10/24/cryptographic-improvements-in-asp-net-4-5-pt-3.aspx)

## <a name="generating-the-tokens"></a><span data-ttu-id="3c418-157">Generación de tokens</span><span class="sxs-lookup"><span data-stu-id="3c418-157">Generating the tokens</span></span>

<span data-ttu-id="3c418-158">Para generar los tokens anti-XSRF, llame al método [@Html.AntiForgeryToken](https://msdn.microsoft.com/library/dd470175.aspx) desde una vista de MVC o @AntiForgery.GetHtml() desde una página de Razor.</span><span class="sxs-lookup"><span data-stu-id="3c418-158">To generate the anti-XSRF tokens, call the [@Html.AntiForgeryToken](https://msdn.microsoft.com/library/dd470175.aspx) method from an MVC view or @AntiForgery.GetHtml() from a Razor page.</span></span> <span data-ttu-id="3c418-159">A continuación, el tiempo de ejecución llevará a cabo los siguientes pasos:</span><span class="sxs-lookup"><span data-stu-id="3c418-159">The runtime will then perform the following steps:</span></span>

1. <span data-ttu-id="3c418-160">Si la solicitud HTTP actual ya contiene un token de sesión anti-XSRF (la cookie anti-XSRF \_\_RequestVerificationToken), se extrae el token de seguridad de él.</span><span class="sxs-lookup"><span data-stu-id="3c418-160">If the current HTTP request already contains an anti-XSRF session token (the anti-XSRF cookie \_\_RequestVerificationToken), the security token is extracted from it.</span></span> <span data-ttu-id="3c418-161">Si la solicitud HTTP no contiene un token de sesión anti-XSRF o si se produce un error en la extracción del token de seguridad, se generará un nuevo token anti-XSRF aleatorio.</span><span class="sxs-lookup"><span data-stu-id="3c418-161">If the HTTP request does not contain an anti-XSRF session token or if extraction of the security token fails, a new random anti-XSRF token will be generated.</span></span>
2. <span data-ttu-id="3c418-162">Un token de campo anti-XSRF se genera mediante el token de seguridad del paso (1) anterior y la identidad del usuario que ha iniciado la sesión actual.</span><span class="sxs-lookup"><span data-stu-id="3c418-162">An anti-XSRF field token is generated using the security token from step (1) above and the identity of the current logged-in user.</span></span> <span data-ttu-id="3c418-163">(Para obtener más información sobre cómo determinar la identidad del usuario, consulte la sección **[escenarios con compatibilidad especial](#_Scenarios_with_special)** más adelante). Además, si se configura un [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/jj158328(v=vs.111).aspx) , el tiempo de ejecución llamará a su método [GetAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.getadditionaldata(v=vs.111).aspx) e incluirá la cadena devuelta en el token de campo.</span><span class="sxs-lookup"><span data-stu-id="3c418-163">(For more information on determining user identity, see the **[Scenarios with special support](#_Scenarios_with_special)** section below.) Additionally, if an [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/jj158328(v=vs.111).aspx) is configured, the runtime will call its [GetAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.getadditionaldata(v=vs.111).aspx) method and include the returned string in the field token.</span></span> <span data-ttu-id="3c418-164">(Consulte la sección **[configuración y extensibilidad](#_Configuration_and_extensibility)** para obtener más información).</span><span class="sxs-lookup"><span data-stu-id="3c418-164">(See the **[Configuration and extensibility](#_Configuration_and_extensibility)** section for more information.)</span></span>
3. <span data-ttu-id="3c418-165">Si se generó un nuevo token anti-XSRF en el paso (1), se creará un nuevo token de sesión que lo incluirá y se agregará a la colección de cookies HTTP salientes.</span><span class="sxs-lookup"><span data-stu-id="3c418-165">If a new anti-XSRF token was generated in step (1), a new session token will be created to contain it and will be added to the outbound HTTP cookies collection.</span></span> <span data-ttu-id="3c418-166">El token de campo del paso (2) se ajustará en un elemento `<input type="hidden" />`, y este marcado HTML será el valor devuelto de `Html.AntiForgeryToken()` o `AntiForgery.GetHtml()`.</span><span class="sxs-lookup"><span data-stu-id="3c418-166">The field token from step (2) will be wrapped in an `<input type="hidden" />` element, and this HTML markup will be the return value of `Html.AntiForgeryToken()` or `AntiForgery.GetHtml()`.</span></span>

## <a name="validating-the-tokens"></a><span data-ttu-id="3c418-167">Validar los tokens</span><span class="sxs-lookup"><span data-stu-id="3c418-167">Validating the tokens</span></span>

<span data-ttu-id="3c418-168">Para validar los tokens anti-XSRF entrantes, el desarrollador incluye un atributo [ValidateAntiForgeryToken](https://msdn.microsoft.com/library/system.web.mvc.validateantiforgerytokenattribute(VS.108).aspx) en su controlador o acción de MVC, o bien llama a `@AntiForgery.Validate()` desde su página de Razor.</span><span class="sxs-lookup"><span data-stu-id="3c418-168">To validate the incoming anti-XSRF tokens, the developer includes a [ValidateAntiForgeryToken](https://msdn.microsoft.com/library/system.web.mvc.validateantiforgerytokenattribute(VS.108).aspx) attribute on her MVC action or controller, or she calls `@AntiForgery.Validate()` from her Razor page.</span></span> <span data-ttu-id="3c418-169">El tiempo de ejecución llevará a cabo los pasos siguientes:</span><span class="sxs-lookup"><span data-stu-id="3c418-169">The runtime will perform the following steps:</span></span>

1. <span data-ttu-id="3c418-170">El token de la sesión entrante y el token de campo se leen y el token anti-XSRF extraído de cada.</span><span class="sxs-lookup"><span data-stu-id="3c418-170">The incoming session token and field token are read and the anti-XSRF token extracted from each.</span></span> <span data-ttu-id="3c418-171">Los tokens anti-XSRF deben ser idénticos según el paso (2) en la rutina de generación.</span><span class="sxs-lookup"><span data-stu-id="3c418-171">The anti-XSRF tokens must be identical per step (2) in the generation routine.</span></span>
2. <span data-ttu-id="3c418-172">Si el usuario actual está autenticado, su nombre de usuario se compara con el nombre de usuario almacenado en el token del campo.</span><span class="sxs-lookup"><span data-stu-id="3c418-172">If the current user is authenticated, her username is compared with the username stored in the field token.</span></span> <span data-ttu-id="3c418-173">Los nombres de usuario deben coincidir.</span><span class="sxs-lookup"><span data-stu-id="3c418-173">The usernames must match.</span></span>
3. <span data-ttu-id="3c418-174">Si se configura un [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) , el tiempo de ejecución llama a su método *ValidateAdditionalData* .</span><span class="sxs-lookup"><span data-stu-id="3c418-174">If an [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) is configured, the runtime calls its *ValidateAdditionalData* method.</span></span> <span data-ttu-id="3c418-175">El método debe devolver el valor booleano *true*.</span><span class="sxs-lookup"><span data-stu-id="3c418-175">The method must return the Boolean value *true*.</span></span>

<span data-ttu-id="3c418-176">Si la validación se realiza correctamente, la solicitud puede continuar.</span><span class="sxs-lookup"><span data-stu-id="3c418-176">If validation succeeds, the request is allowed to proceed.</span></span> <span data-ttu-id="3c418-177">Si se produce un error en la validación, el marco de trabajo producirá una *HttpAntiForgeryException*.</span><span class="sxs-lookup"><span data-stu-id="3c418-177">If validation fails, the framework will throw an *HttpAntiForgeryException*.</span></span>

## <a name="failure-conditions"></a><span data-ttu-id="3c418-178">Condiciones de error</span><span class="sxs-lookup"><span data-stu-id="3c418-178">Failure conditions</span></span>

<span data-ttu-id="3c418-179">A partir de ASP.NET Web Stack Runtime V2, cualquier *HttpAntiForgeryException* que se inicie durante la validación contendrá información detallada sobre lo que salió mal.</span><span class="sxs-lookup"><span data-stu-id="3c418-179">Starting with The ASP.NET Web Stack Runtime v2, any *HttpAntiForgeryException* that is thrown during validation will contain detailed information about what went wrong.</span></span> <span data-ttu-id="3c418-180">Las condiciones de error definidas actualmente son:</span><span class="sxs-lookup"><span data-stu-id="3c418-180">The currently defined failure conditions are:</span></span>

- <span data-ttu-id="3c418-181">El token de la sesión o el token del formulario no está presente en la solicitud.</span><span class="sxs-lookup"><span data-stu-id="3c418-181">The session token or form token is not present in the request.</span></span>
- <span data-ttu-id="3c418-182">El token de sesión o el token de formulario son ilegibles.</span><span class="sxs-lookup"><span data-stu-id="3c418-182">The session token or form token is unreadable.</span></span> <span data-ttu-id="3c418-183">La causa más probable es que una granja ejecute versiones no coincidentes del tiempo de ejecución de la pila de Web ASP.NET o una granja en la que el elemento &lt;machineKey&gt; de Web. config difiere entre equipos.</span><span class="sxs-lookup"><span data-stu-id="3c418-183">The most likely cause of this is a farm running mismatched versions of The ASP.NET Web Stack Runtime or a farm where the &lt;machineKey&gt; element in Web.config differs between machines.</span></span> <span data-ttu-id="3c418-184">Puede usar una herramienta como Fiddler para forzar esta excepción mediante la manipulación de tokens antixsrf.</span><span class="sxs-lookup"><span data-stu-id="3c418-184">You can use a tool such as Fiddler to force this exception by tampering with either anti-XSRF token.</span></span>
- <span data-ttu-id="3c418-185">El token de sesión y el token de campo se intercambiaron.</span><span class="sxs-lookup"><span data-stu-id="3c418-185">The session token and field token were swapped.</span></span>
- <span data-ttu-id="3c418-186">El token de sesión y el token de campo contienen tokens de seguridad no coincidentes.</span><span class="sxs-lookup"><span data-stu-id="3c418-186">The session token and field token contain mismatched security tokens.</span></span>
- <span data-ttu-id="3c418-187">El nombre de usuario incrustado en el token de campo no coincide con el nombre de usuario del usuario que ha iniciado la sesión actual.</span><span class="sxs-lookup"><span data-stu-id="3c418-187">The username embedded within the field token does not match the current logged-in user's username.</span></span>
- <span data-ttu-id="3c418-188">El método *[IAntiForgeryAdditionalDataProvider. ValidateAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.validateadditionaldata(v=vs.111).aspx)* devolvió *false*.</span><span class="sxs-lookup"><span data-stu-id="3c418-188">The *[IAntiForgeryAdditionalDataProvider.ValidateAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.validateadditionaldata(v=vs.111).aspx)* method returned *false*.</span></span>

<span data-ttu-id="3c418-189">Los servicios antixsrf también pueden realizar comprobaciones adicionales durante la generación o la validación de tokens, y los errores que se produzcan durante estas comprobaciones pueden dar lugar a que se inicien excepciones.</span><span class="sxs-lookup"><span data-stu-id="3c418-189">The anti-XSRF facilities may also perform additional checking during token generation or validation, and failures during these checks may result in exceptions being thrown.</span></span> <span data-ttu-id="3c418-190">Consulte las secciones sobre la autenticación y la **[configuración y la extensibilidad](#_Configuration_and_extensibility)** [basadas en WIF/ACS/notificaciones](#_WIF_ACS) para obtener más información.</span><span class="sxs-lookup"><span data-stu-id="3c418-190">See the [WIF / ACS / claims-based authentication](#_WIF_ACS) and **[Configuration and extensibility](#_Configuration_and_extensibility)** sections for more information.</span></span>

<a id="_Scenarios_with_special"></a>

## <a name="scenarios-with-special-support"></a><span data-ttu-id="3c418-191">Escenarios con compatibilidad especial</span><span class="sxs-lookup"><span data-stu-id="3c418-191">Scenarios with special support</span></span>

### <a name="anonymous-authentication"></a><span data-ttu-id="3c418-192">Autenticación anónima</span><span class="sxs-lookup"><span data-stu-id="3c418-192">Anonymous authentication</span></span>

<span data-ttu-id="3c418-193">El sistema anti-XSRF contiene compatibilidad especial con usuarios anónimos, donde "Anonymous" se define como un usuario en el que la propiedad *IIdentity. IsAuthenticated* devuelve *false*.</span><span class="sxs-lookup"><span data-stu-id="3c418-193">The anti-XSRF system contains special support for anonymous users, where "anonymous" is defined as a user where the *IIdentity.IsAuthenticated* property returns *false*.</span></span> <span data-ttu-id="3c418-194">Los escenarios incluyen la protección de XSRF en la página de inicio de sesión (antes de que se autentique el usuario) y los esquemas de autenticación personalizados en los que la aplicación utiliza un mecanismo distinto de *IIdentity* para identificar a los usuarios.</span><span class="sxs-lookup"><span data-stu-id="3c418-194">Scenarios include providing XSRF protection to the login page (before the user is authenticated) and custom authentication schemes where the application uses a mechanism other than *IIdentity* to identify users.</span></span>

<span data-ttu-id="3c418-195">Para admitir estos escenarios, recuerde que los tokens de sesión y de campo están Unidos por un token de seguridad, que es un identificador opaco generado aleatoriamente de 128 bits.</span><span class="sxs-lookup"><span data-stu-id="3c418-195">To support these scenarios, recall that the session and field tokens are joined by a security token, which is a 128-bit randomly-generated opaque identifier.</span></span> <span data-ttu-id="3c418-196">Este token de seguridad se usa para realizar el seguimiento de la sesión de un usuario individual a medida que navega por el sitio, por lo que sirve de forma eficaz el propósito de un identificador anónimo.</span><span class="sxs-lookup"><span data-stu-id="3c418-196">This security token is used to track an individual user's session as she navigates the site, so it effectively serves the purpose of an anonymous identifier.</span></span> <span data-ttu-id="3c418-197">Se utiliza una cadena vacía en lugar del nombre de usuario para las rutinas de generación y validación descritas anteriormente.</span><span class="sxs-lookup"><span data-stu-id="3c418-197">An empty string is used in place of the username for the generation and validation routines described above.</span></span>

<a id="_WIF_ACS"></a>

### <a name="wif--acs--claims-based-authentication"></a><span data-ttu-id="3c418-198">WIF/ACS/autenticación basada en notificaciones</span><span class="sxs-lookup"><span data-stu-id="3c418-198">WIF / ACS / claims-based authentication</span></span>

<span data-ttu-id="3c418-199">Normalmente, las clases *IIdentity* integradas en el .NET Framework tienen la propiedad de que *IIdentity.Name* es suficiente para identificar de forma única a un usuario determinado dentro de una aplicación determinada.</span><span class="sxs-lookup"><span data-stu-id="3c418-199">Normally, the *IIdentity* classes built in to the .NET Framework have the property that *IIdentity.Name* is sufficient to uniquely identify a particular user within a particular application.</span></span> <span data-ttu-id="3c418-200">Por ejemplo, *FormsIdentity.Name* devuelve el nombre de usuario almacenado en la base de datos de pertenencia (que es único para todas las aplicaciones en función de esa base de datos), *WindowsIdentity.Name* devuelve la identidad calificada del dominio del usuario, etc.</span><span class="sxs-lookup"><span data-stu-id="3c418-200">For example, *FormsIdentity.Name* returns the username stored in the membership database (which is unique for all applications depending on that database), *WindowsIdentity.Name* returns the domain-qualified identity of the user, and so on.</span></span> <span data-ttu-id="3c418-201">Estos sistemas proporcionan no solo autenticación; también *identifican* a los usuarios de una aplicación.</span><span class="sxs-lookup"><span data-stu-id="3c418-201">These systems provide not only authentication; they also *identify* users to an application.</span></span>

<span data-ttu-id="3c418-202">La autenticación basada en notificaciones, por otro lado, no requiere necesariamente la identificación de un usuario determinado.</span><span class="sxs-lookup"><span data-stu-id="3c418-202">Claims-based authentication, on the other hand, does not necessarily require identifying a particular user.</span></span> <span data-ttu-id="3c418-203">En su lugar, los tipos *ClaimsPrincipal* y *ClaimsIdentity* están asociados a un conjunto de instancias de *notificación* , donde las notificaciones individuales pueden ser "más de 18 años de edad" o "es un administrador".</span><span class="sxs-lookup"><span data-stu-id="3c418-203">Instead, the *ClaimsPrincipal* and *ClaimsIdentity* types are associated with a set of *Claim* instances, where the individual claims might be "is 18+ years of age" or "is an administrator" to anything else.</span></span> <span data-ttu-id="3c418-204">Como el usuario no se ha identificado necesariamente, el tiempo de ejecución no puede usar la propiedad *ClaimsIdentity.Name* como identificador único para este usuario concreto.</span><span class="sxs-lookup"><span data-stu-id="3c418-204">Since the user hasn't necessarily been identified, the runtime cannot use the *ClaimsIdentity.Name* property as a unique identifier for this particular user.</span></span> <span data-ttu-id="3c418-205">El equipo ha detectado ejemplos del mundo real en los que *ClaimsIdentity.Name* devuelve *null*, devuelve un nombre descriptivo (Mostrar) o, de lo contrario, devuelve una cadena que no es adecuada para su uso como identificador único para el usuario.</span><span class="sxs-lookup"><span data-stu-id="3c418-205">The team has seen real-world examples where *ClaimsIdentity.Name* returns *null*, returns a friendly (display) name, or otherwise returns a string that isn't appropriate for use as a unique identifier for the user.</span></span>

<span data-ttu-id="3c418-206">Muchas de las implementaciones que usan la autenticación basada en notificaciones usan [Azure Access Control Service](https://msdn.microsoft.com/library/windowsazure/gg429786.aspx) (ACS) en concreto.</span><span class="sxs-lookup"><span data-stu-id="3c418-206">Many of deployments which use claims-based authentication are using [Azure Access Control Service](https://msdn.microsoft.com/library/windowsazure/gg429786.aspx) (ACS) in particular.</span></span> <span data-ttu-id="3c418-207">ACS permite al desarrollador configurar proveedores de *identidades* individuales (por ejemplo, ADFS, el proveedor de cuentas Microsoft, los proveedores de OpenID como Yahoo!, etc.) y los proveedores de identidades devuelven los *identificadores de nombre*.</span><span class="sxs-lookup"><span data-stu-id="3c418-207">ACS allows the developer to configure individual *identity providers* (such as ADFS, the Microsoft Account provider, OpenID providers like Yahoo!, etc.), and the identity providers return *name identifiers*.</span></span> <span data-ttu-id="3c418-208">Estos identificadores de nombre pueden contener información de identificación personal (PII) como una dirección de correo electrónico, o bien se anónimos como un identificador personal privado (PPID).</span><span class="sxs-lookup"><span data-stu-id="3c418-208">These name identifiers may contain Personally Identifiable Information (PII) like an email address, or they could be anonymized like a Private Personal Identifier (PPID).</span></span> <span data-ttu-id="3c418-209">Sin tener en consideración, la tupla (proveedor de identidades, identificador de nombre) actúa suficientemente como un token de seguimiento adecuado para un usuario determinado mientras está explorando el sitio, por lo que el tiempo de ejecución de la pila Web ASP.NET puede usar la tupla en lugar del nombre de usuario al generar y validando los tokens de campo anti-XSRF.</span><span class="sxs-lookup"><span data-stu-id="3c418-209">Regardless, the tuple (identity provider, name identifier) sufficiently serves as an appropriate tracking token for a particular user while she is browsing the site, so the ASP.NET Web Stack Runtime can use the tuple in place of the username when generating and validating anti-XSRF field tokens.</span></span> <span data-ttu-id="3c418-210">Los URI específicos para el proveedor de identidades y el identificador de nombre son:</span><span class="sxs-lookup"><span data-stu-id="3c418-210">The particular URIs for the identity provider and the name identifier are :</span></span>

- `http://schemas.microsoft.com/accesscontrolservice/2010/07/claims/identityprovider`
- `http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier`

<span data-ttu-id="3c418-211">(consulte esta [Página de documento de ACS](https://msdn.microsoft.com/library/windowsazure/gg185971.aspx) para obtener más información).</span><span class="sxs-lookup"><span data-stu-id="3c418-211">(see this [ACS doc page](https://msdn.microsoft.com/library/windowsazure/gg185971.aspx) for more info.)</span></span>

<span data-ttu-id="3c418-212">Al generar o validar un token, el tiempo de ejecución de la pila de Web ASP.NET en tiempo de ejecución intenta enlazar a los tipos:</span><span class="sxs-lookup"><span data-stu-id="3c418-212">When generating or validating a token, the ASP.NET Web Stack Runtime will at runtime try binding to the types:</span></span>

- <span data-ttu-id="3c418-213">`Microsoft.IdentityModel.Claims.IClaimsIdentity, Microsoft.IdentityModel, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35` (para el SDK de WIF).</span><span class="sxs-lookup"><span data-stu-id="3c418-213">`Microsoft.IdentityModel.Claims.IClaimsIdentity, Microsoft.IdentityModel, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35` (For the WIF SDK.)</span></span>
- <span data-ttu-id="3c418-214">`System.Security.Claims.ClaimsIdentity` (para .NET 4,5).</span><span class="sxs-lookup"><span data-stu-id="3c418-214">`System.Security.Claims.ClaimsIdentity` (For .NET 4.5).</span></span>

<span data-ttu-id="3c418-215">Si estos tipos existen, y si el *IIIIdentity* del usuario actual implementa o subclase de uno de estos tipos, el servicio anti-XSRF usará la tupla (proveedor de identidades, identificador de nombre) en lugar del nombre de usuario al generar y validar los tokens.</span><span class="sxs-lookup"><span data-stu-id="3c418-215">If these types exist, and if the current user's *IIIIdentity* implements or subclasses one of these types, the anti-XSRF facility will use the (identity provider, name identifier) tuple in place of the username when generating and validating the tokens.</span></span> <span data-ttu-id="3c418-216">Si no hay ninguna tupla de este tipo, se producirá un error en la solicitud y se describirá al desarrollador cómo configurar el sistema anti-XSRF para comprender el mecanismo de autenticación específico basado en notificaciones en uso.</span><span class="sxs-lookup"><span data-stu-id="3c418-216">If no such tuple is present, the request will fail with an error describing to the developer how to configure the anti-XSRF system to understand the particular claims-based authentication mechanism in use.</span></span> <span data-ttu-id="3c418-217">Vea la sección **[configuración y extensibilidad](#_Configuration_and_extensibility)** para obtener más información.</span><span class="sxs-lookup"><span data-stu-id="3c418-217">See the **[Configuration and extensibility](#_Configuration_and_extensibility)** section for more information.</span></span>

### <a name="oauth--openid-authentication"></a><span data-ttu-id="3c418-218">Autenticación de OAuth/OpenID</span><span class="sxs-lookup"><span data-stu-id="3c418-218">OAuth / OpenID authentication</span></span>

<span data-ttu-id="3c418-219">Por último, la instalación de anti-XSRF tiene compatibilidad especial con las aplicaciones que usan la autenticación de OAuth o OpenID.</span><span class="sxs-lookup"><span data-stu-id="3c418-219">Finally, the anti-XSRF facility has special support for applications which use OAuth or OpenID authentication.</span></span> <span data-ttu-id="3c418-220">Esta compatibilidad se basa en la heurística: Si el *IIdentity.Name* actual comienza con http://o https://, las comparaciones de nombre de usuario se realizarán mediante un comparador ordinal en lugar del comparador de OrdinalIgnoreCase predeterminado.</span><span class="sxs-lookup"><span data-stu-id="3c418-220">This support is heuristic-based: if the current *IIdentity.Name* begins with http:// or https://, then username comparisons will be done using an Ordinal comparer rather than the default OrdinalIgnoreCase comparer.</span></span>

<a id="_Configuration_and_extensibility"></a>

## <a name="configuration-and-extensibility"></a><span data-ttu-id="3c418-221">Configuración y extensibilidad</span><span class="sxs-lookup"><span data-stu-id="3c418-221">Configuration and extensibility</span></span>

<span data-ttu-id="3c418-222">En ocasiones, es posible que los desarrolladores quieran un mayor control sobre los comportamientos de la generación y validación de XSRF.</span><span class="sxs-lookup"><span data-stu-id="3c418-222">Occasionally, developers may want tighter control over the anti-XSRF generation and validation behaviors.</span></span> <span data-ttu-id="3c418-223">Por ejemplo, es posible que el comportamiento predeterminado de las aplicaciones web y MVC para agregar cookies HTTP a la respuesta no sea deseable y que el desarrollador desee conservar los tokens en otra parte.</span><span class="sxs-lookup"><span data-stu-id="3c418-223">For example, perhaps the MVC and Web Pages helpers' default behavior of automatically adding HTTP cookies to the response is undesirable, and the developer may wish to persist the tokens elsewhere.</span></span> <span data-ttu-id="3c418-224">Existen dos API que le servirán de ayuda:</span><span class="sxs-lookup"><span data-stu-id="3c418-224">There exist two APIs to assist with this:</span></span>

`AntiForgery.GetTokens(string oldCookieToken, out string newCookieToken, out string formToken);`  
`AntiForgery.Validate(string cookieToken, string formToken);`

<span data-ttu-id="3c418-225">El método *GetTokens* toma como entrada un token de sesión de comprobación de solicitud de XSRF existente (que puede ser null) y genera como resultado un nuevo token de sesión de comprobación de solicitud de XSRF y un token de campo.</span><span class="sxs-lookup"><span data-stu-id="3c418-225">The *GetTokens* method takes as input an existing XSRF request verification session token (which may be null) and produces as output a new XSRF request verification session token and field token.</span></span> <span data-ttu-id="3c418-226">Los tokens son simplemente cadenas opacas sin decoración. el valor de *formToken* para la instancia no se encapsulará en una etiqueta de entrada &lt;&gt;.</span><span class="sxs-lookup"><span data-stu-id="3c418-226">The tokens are simply opaque strings with no decoration; the *formToken* value will for instance not be wrapped in an &lt;input&gt; tag.</span></span> <span data-ttu-id="3c418-227">El valor de *newCookieToken* puede ser null; Si esto ocurre, el valor *oldCookieToken* sigue siendo válido y no es necesario establecer ninguna cookie de respuesta nueva.</span><span class="sxs-lookup"><span data-stu-id="3c418-227">The *newCookieToken* value may be null; if this occurs, then the *oldCookieToken* value is still valid and no new response cookie need be set.</span></span> <span data-ttu-id="3c418-228">El autor de la llamada de *GetTokens* es responsable de conservar las cookies de respuesta necesarias o de generar cualquier marcado necesario; el método *GetTokens* en sí no modificará la respuesta como efecto secundario.</span><span class="sxs-lookup"><span data-stu-id="3c418-228">The caller of *GetTokens* is responsible for persisting any necessary response cookies or generating any necessary markup; the *GetTokens* method itself will not alter the response as a side effect.</span></span> <span data-ttu-id="3c418-229">El método *Validate* toma la sesión entrante y los tokens de campo, y ejecuta la lógica de validación mencionada anteriormente.</span><span class="sxs-lookup"><span data-stu-id="3c418-229">The *Validate* method takes the incoming session and field tokens and runs the aforementioned validation logic over them.</span></span>

### <a name="antiforgeryconfig"></a><span data-ttu-id="3c418-230">AntiForgeryConfig</span><span class="sxs-lookup"><span data-stu-id="3c418-230">AntiForgeryConfig</span></span>

<span data-ttu-id="3c418-231">El desarrollador puede configurar el sistema anti-XSRF desde el inicio de la aplicación\_.</span><span class="sxs-lookup"><span data-stu-id="3c418-231">The developer may configure the anti-XSRF system from Application\_Start.</span></span> <span data-ttu-id="3c418-232">La configuración es mediante programación.</span><span class="sxs-lookup"><span data-stu-id="3c418-232">Configuration is programmatic.</span></span> <span data-ttu-id="3c418-233">A continuación se describen las propiedades del tipo *AntiForgeryConfig* estático.</span><span class="sxs-lookup"><span data-stu-id="3c418-233">The properties of the static *AntiForgeryConfig* type are described below.</span></span> <span data-ttu-id="3c418-234">La mayoría de los usuarios que usan notificaciones querrán establecer la propiedad UniqueClaimTypeIdentifier.</span><span class="sxs-lookup"><span data-stu-id="3c418-234">Most users using claims will want to set the UniqueClaimTypeIdentifier property.</span></span>

| <span data-ttu-id="3c418-235">**Property**</span><span class="sxs-lookup"><span data-stu-id="3c418-235">**Property**</span></span> | <span data-ttu-id="3c418-236">**Descripción**</span><span class="sxs-lookup"><span data-stu-id="3c418-236">**Description**</span></span> |
| --- | --- |
| <span data-ttu-id="3c418-237">**AdditionalDataProvider**</span><span class="sxs-lookup"><span data-stu-id="3c418-237">**AdditionalDataProvider**</span></span> | <span data-ttu-id="3c418-238">[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) que proporciona datos adicionales durante la generación de tokens y consume datos adicionales durante la validación de tokens.</span><span class="sxs-lookup"><span data-stu-id="3c418-238">An [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) that provides additional data during token generation and consumes additional data during token validation.</span></span> <span data-ttu-id="3c418-239">El valor predeterminado es *null*.</span><span class="sxs-lookup"><span data-stu-id="3c418-239">The default value is *null*.</span></span> <span data-ttu-id="3c418-240">Para obtener más información, vea la sección [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) .</span><span class="sxs-lookup"><span data-stu-id="3c418-240">For more information, see the [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) section.</span></span> |
| <span data-ttu-id="3c418-241">**CookieName**</span><span class="sxs-lookup"><span data-stu-id="3c418-241">**CookieName**</span></span> | <span data-ttu-id="3c418-242">Una cadena que proporciona el nombre de la cookie HTTP que se utiliza para almacenar el token de sesión anti-XSRF.</span><span class="sxs-lookup"><span data-stu-id="3c418-242">A string that provides the name of the HTTP cookie that is used to store the anti-XSRF session token.</span></span> <span data-ttu-id="3c418-243">Si no se establece este valor, se generará automáticamente un nombre en función de la ruta de acceso virtual implementada de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="3c418-243">If this value is not set, a name will be automatically generated based on the application's deployed virtual path.</span></span> <span data-ttu-id="3c418-244">El valor predeterminado es *null*.</span><span class="sxs-lookup"><span data-stu-id="3c418-244">The default value is *null*.</span></span> |
| <span data-ttu-id="3c418-245">**RequireSsl**</span><span class="sxs-lookup"><span data-stu-id="3c418-245">**RequireSsl**</span></span> | <span data-ttu-id="3c418-246">Un valor booleano que indica si se requiere que los tokens antixsrf se envíen a través de un canal seguro para SSL.</span><span class="sxs-lookup"><span data-stu-id="3c418-246">A Boolean that dictates whether the anti-XSRF tokens are required to be submitted over an SSL-secured channel.</span></span> <span data-ttu-id="3c418-247">Si este valor es *true*, todas las cookies generadas automáticamente tendrán establecida la marca "Secure" y las API antixsrf se iniciarán si se llama desde dentro de una solicitud que no se envía a través de SSL.</span><span class="sxs-lookup"><span data-stu-id="3c418-247">If this value is *true*, any automatically-generated cookies will have the "secure" flag set, and the anti-XSRF APIs will throw if called from within a request that is not submitted via SSL.</span></span> <span data-ttu-id="3c418-248">El valor predeterminado es *false*.</span><span class="sxs-lookup"><span data-stu-id="3c418-248">The default value is *false*.</span></span> |
| <span data-ttu-id="3c418-249">**SuppressIdentityHeuristicChecks**</span><span class="sxs-lookup"><span data-stu-id="3c418-249">**SuppressIdentityHeuristicChecks**</span></span> | <span data-ttu-id="3c418-250">Un valor booleano que indica si el sistema anti-XSRF debe desactivar su compatibilidad con identidades basadas en notificaciones.</span><span class="sxs-lookup"><span data-stu-id="3c418-250">A Boolean that dictates whether the anti-XSRF system should deactivate its support for claims-based identities.</span></span> <span data-ttu-id="3c418-251">Si este valor es *true*, el sistema asumirá que *IIdentity.Name* es adecuado para su uso como un identificador único por usuario y no intentará *IClaimsIdentity* o *ClClaimsIdentity* especial como se describe en [WIF/ACS/ sección de autenticación basada en notificaciones](#_WIF_ACS) .</span><span class="sxs-lookup"><span data-stu-id="3c418-251">If this value is *true*, the system will assume that *IIdentity.Name* is appropriate for use as a unique per-user identifier and will not try to special-case *IClaimsIdentity* or *ClClaimsIdentity* as described in the [WIF / ACS / claims-based authentication](#_WIF_ACS) section.</span></span> <span data-ttu-id="3c418-252">El valor predeterminado es `false`.</span><span class="sxs-lookup"><span data-stu-id="3c418-252">The default value is `false`.</span></span> |
| <span data-ttu-id="3c418-253">**UniqueClaimTypeIdentifier**</span><span class="sxs-lookup"><span data-stu-id="3c418-253">**UniqueClaimTypeIdentifier**</span></span> | <span data-ttu-id="3c418-254">Una cadena que indica qué tipo de notificaciones es adecuado para su uso como un identificador único por usuario.</span><span class="sxs-lookup"><span data-stu-id="3c418-254">A string that indicates which claim type is appropriate for use as a unique per-user identifier.</span></span> <span data-ttu-id="3c418-255">Si se establece este valor y el *IIdentity* actual está basado en notificaciones, el sistema intentará extraer una notificación del tipo especificado por *UniqueClaimTypeIdentifier*, y se usará el valor correspondiente en lugar del nombre de usuario del usuario cuando generar el token de campo.</span><span class="sxs-lookup"><span data-stu-id="3c418-255">If this value is set and the current *IIdentity* is claims-based, the system will attempt to extract a claim of the type specified by *UniqueClaimTypeIdentifier*, and the corresponding value will be used in place of the user's username when generating the field token.</span></span> <span data-ttu-id="3c418-256">Si no se encuentra el tipo de demanda, el sistema producirá un error en la solicitud.</span><span class="sxs-lookup"><span data-stu-id="3c418-256">If the claim type is not found, the system will fail the request.</span></span> <span data-ttu-id="3c418-257">El valor predeterminado es *null*, lo que indica que el sistema debe usar la tupla (proveedor de identidades, identificador de nombre) tal y como se ha descrito anteriormente en lugar del nombre de usuario del usuario.</span><span class="sxs-lookup"><span data-stu-id="3c418-257">The default value is *null*, which indicates that the system should use the (identity provider, name identifier) tuple as previously described in place of the user's username.</span></span> |

<a id="_IAntiForgeryAdditionalDataProvider"></a>

### <a name="iantiforgeryadditionaldataprovider"></a><span data-ttu-id="3c418-258">IAntiForgeryAdditionalDataProvider</span><span class="sxs-lookup"><span data-stu-id="3c418-258">IAntiForgeryAdditionalDataProvider</span></span>

<span data-ttu-id="3c418-259">El tipo *[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)* permite a los desarrolladores ampliar el comportamiento del sistema anti-XSRF mediante el recorrido de ida y vuelta por los datos adicionales de cada token.</span><span class="sxs-lookup"><span data-stu-id="3c418-259">The *[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)* type allows developers to extend the behavior of the anti-XSRF system by round-tripping additional data in each token.</span></span> <span data-ttu-id="3c418-260">Se llama al método *GetAdditionalData* cada vez que se genera un token de campo y el valor devuelto se incrusta en el token generado.</span><span class="sxs-lookup"><span data-stu-id="3c418-260">The *GetAdditionalData* method is called each time a field token is generated, and the return value is embedded within the generated token.</span></span> <span data-ttu-id="3c418-261">Un implementador podría devolver una marca de tiempo, un valor de seguridad (nonce) o cualquier otro valor que desee de este método.</span><span class="sxs-lookup"><span data-stu-id="3c418-261">An implementer could return a timestamp, a nonce, or any other value she wishes from this method.</span></span>

<span data-ttu-id="3c418-262">Del mismo modo, se llama al método *ValidateAdditionalData* cada vez que se valida un token de campo y la cadena de "datos adicionales" que se incrustó en el token se pasa al método.</span><span class="sxs-lookup"><span data-stu-id="3c418-262">Similarly, the *ValidateAdditionalData* method is called each time a field token is validated, and the "additional data" string that was embedded within the token is passed to the method.</span></span> <span data-ttu-id="3c418-263">La rutina de validación podría implementar un tiempo de espera (comprobando la hora actual con la hora que se almacenó cuando se creó el token), una rutina de comprobación de nonce o cualquier otra lógica deseada.</span><span class="sxs-lookup"><span data-stu-id="3c418-263">The validation routine could implement a timeout (by checking the current time against the time that was stored when the token was created), a nonce checking routine, or any other desired logic.</span></span>

## <a name="design-decisions-and-security-considerations"></a><span data-ttu-id="3c418-264">Decisiones de diseño y consideraciones de seguridad</span><span class="sxs-lookup"><span data-stu-id="3c418-264">Design decisions and security considerations</span></span>

<span data-ttu-id="3c418-265">Técnicamente, el token de seguridad que vincula los tokens de sesión y de campo solo es necesario cuando se intenta proteger usuarios anónimos o no autenticados contra ataques de XSRF.</span><span class="sxs-lookup"><span data-stu-id="3c418-265">The security token that links the session and field tokens is technically only necessary when trying to protect anonymous / unauthenticated users against XSRF attacks.</span></span> <span data-ttu-id="3c418-266">Cuando se autentica el usuario, el propio token de autenticación (supuestamente enviado en forma de cookie) podría usarse como una mitad de un par de tokens de sincronizador.</span><span class="sxs-lookup"><span data-stu-id="3c418-266">When the user is authenticated, the authentication token itself (presumably submitted in the form of a cookie) could be used as one half of a synchronizer token pair.</span></span> <span data-ttu-id="3c418-267">Sin embargo, hay escenarios válidos para proteger las páginas de inicio de sesión de los usuarios no autenticados, y la lógica anti-XSRF se hizo más sencilla generando y validando siempre el token de seguridad, incluso para los usuarios autenticados.</span><span class="sxs-lookup"><span data-stu-id="3c418-267">However, there are valid scenarios for protecting login pages hit by unauthenticated users, and the anti-XSRF logic was made simpler by always generating and validating the security token, even for authenticated users.</span></span> <span data-ttu-id="3c418-268">También proporciona protección adicional en caso de que un atacante haya puesto en peligro un token de campo, ya que el establecimiento o la adivinación del token de sesión sería otro obstáculo para que el atacante lo solucione.</span><span class="sxs-lookup"><span data-stu-id="3c418-268">It also does provide some additional protection in the event that a field token is ever compromised by an attacker, as setting or guessing the session token would be another hurdle for the attacker to overcome.</span></span>

<span data-ttu-id="3c418-269">Los desarrolladores deben tener cuidado cuando se hospeden varias aplicaciones en un único dominio.</span><span class="sxs-lookup"><span data-stu-id="3c418-269">Developers should use caution when multiple applications are hosted in a single domain.</span></span> <span data-ttu-id="3c418-270">Por ejemplo, aunque *example1.CloudApp.net* y *example2.CloudApp.net* son hosts diferentes, hay una relación de confianza implícita entre todos los hosts del dominio *\*. CloudApp.net* .</span><span class="sxs-lookup"><span data-stu-id="3c418-270">For example, even though *example1.cloudapp.net* and *example2.cloudapp.net* are different hosts, there is an implicit trust relationship between all hosts under the *\*.cloudapp.net* domain.</span></span> <span data-ttu-id="3c418-271">Esta relación de confianza implícita [permite que los hosts potencialmente que no son de confianza afecten a las cookies de los demás](http://stackoverflow.com/questions/9636857/how-can-asp-net-or-asp-net-mvc-be-protected-from-related-domain-cookie-attacks) (las directivas del mismo origen que rigen las solicitudes Ajax no se aplican necesariamente a las cookies http).</span><span class="sxs-lookup"><span data-stu-id="3c418-271">This implicit trust relationship [allows potentially untrusted hosts to affect each other's cookies](http://stackoverflow.com/questions/9636857/how-can-asp-net-or-asp-net-mvc-be-protected-from-related-domain-cookie-attacks) (the same-origin policies that govern AJAX requests do not necessarily apply to HTTP cookies).</span></span> <span data-ttu-id="3c418-272">El tiempo de ejecución de la pila Web de ASP.NET proporciona una mitigación en que el nombre de usuario se inserta en el token de campo, por lo que incluso si un subdominio malintencionado puede sobrescribir un token de sesión, no podrá generar un token de campo válido para el usuario.</span><span class="sxs-lookup"><span data-stu-id="3c418-272">The ASP.NET Web Stack Runtime provides some mitigation in that the username is embedded into the field token, so even if a malicious subdomain is able to overwrite a session token it will be unable to generate a valid field token for the user.</span></span> <span data-ttu-id="3c418-273">Sin embargo, cuando se hospeda en este tipo de entorno, las rutinas antixsrf integradas todavía no pueden defenderse contra el secuestro de sesión o el inicio de sesión de XSRF.</span><span class="sxs-lookup"><span data-stu-id="3c418-273">However, when hosted in such an environment the built-in anti-XSRF routines still cannot defend against session hijacking or login XSRF.</span></span>

<span data-ttu-id="3c418-274">Las rutinas anti-XSRF no se defienden actualmente contra [el secuestro](https://www.owasp.org/index.php/Clickjacking).</span><span class="sxs-lookup"><span data-stu-id="3c418-274">The anti-XSRF routines currently do not defend against [clickjacking](https://www.owasp.org/index.php/Clickjacking).</span></span> <span data-ttu-id="3c418-275">Las aplicaciones que quieran defenderse frente a el secuestro pueden hacerlo fácilmente mediante el envío de un encabezado X-Frame-Options: SAMEORIGIN con cada respuesta.</span><span class="sxs-lookup"><span data-stu-id="3c418-275">Applications that wish to defend themselves against clickjacking may easily do so by sending an X-Frame-Options: SAMEORIGIN header with each response.</span></span> <span data-ttu-id="3c418-276">Este encabezado es compatible con todos los exploradores recientes.</span><span class="sxs-lookup"><span data-stu-id="3c418-276">This header is supported by all recent browsers.</span></span> <span data-ttu-id="3c418-277">Para obtener más información, consulte el [blog de IE](https://blogs.msdn.com/b/ieinternals/archive/2010/03/30/combating-clickjacking-with-x-frame-options.aspx), el blog de [SDL](https://blogs.msdn.com/b/sdl/archive/2009/02/05/clickjacking-defense-in-ie8.aspx)y [OWASP](https://www.owasp.org/index.php/Clickjacking).</span><span class="sxs-lookup"><span data-stu-id="3c418-277">For more information, see the [IE blog](https://blogs.msdn.com/b/ieinternals/archive/2010/03/30/combating-clickjacking-with-x-frame-options.aspx), the [SDL blog](https://blogs.msdn.com/b/sdl/archive/2009/02/05/clickjacking-defense-in-ie8.aspx), and [OWASP](https://www.owasp.org/index.php/Clickjacking).</span></span> <span data-ttu-id="3c418-278">En algunas versiones futuras, el tiempo de ejecución de la pila Web de ASP.NET puede hacer que las aplicaciones de la aplicación Web de MVC y de las páginas web configuran automáticamente este encabezado para que las aplicaciones se protejan automáticamente contra este ataque.</span><span class="sxs-lookup"><span data-stu-id="3c418-278">The ASP.NET Web Stack Runtime may in some future release make the MVC and Web Pages anti-XSRF helpers automatically set this header so that applications are automatically protected against this attack.</span></span>

<span data-ttu-id="3c418-279">Los desarrolladores web deben continuar para asegurarse de que su sitio no sea vulnerable a los ataques XSS.</span><span class="sxs-lookup"><span data-stu-id="3c418-279">Web developers should continue to ensure that their site is not vulnerable to XSS attacks.</span></span> <span data-ttu-id="3c418-280">Los ataques XSS son muy eficaces y un ataque correcto también interrumpiría las defensas en tiempo de ejecución de la pila Web ASP.NET frente a ataques XSRF.</span><span class="sxs-lookup"><span data-stu-id="3c418-280">XSS attacks are very powerful, and a successful exploit would also break the ASP.NET Web Stack Runtime defenses against XSRF attacks.</span></span>

## <a name="acknowledgment"></a><span data-ttu-id="3c418-281">Confirmación</span><span class="sxs-lookup"><span data-stu-id="3c418-281">Acknowledgment</span></span>

<span data-ttu-id="3c418-282">[@LeviBroderick](https://twitter.com/LeviBroderick), que escribió gran parte del código de seguridad de ASP.net en la mayor parte de esta información.</span><span class="sxs-lookup"><span data-stu-id="3c418-282">[@LeviBroderick](https://twitter.com/LeviBroderick), who wrote much of the ASP.NET security code the bulk of this information.</span></span>
