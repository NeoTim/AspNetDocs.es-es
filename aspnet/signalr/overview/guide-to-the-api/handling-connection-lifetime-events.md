---
uid: signalr/overview/guide-to-the-api/handling-connection-lifetime-events
title: Descripción y control de eventos de duración de la conexión en Signalr | Microsoft Docs
author: bradygaster
description: En este artículo se describe cómo usar los eventos expuestos por la API de hubs.
ms.author: bradyg
ms.date: 01/15/2019
ms.assetid: 03960de2-8d95-4444-9169-4426dcc64913
msc.legacyurl: /signalr/overview/guide-to-the-api/handling-connection-lifetime-events
msc.type: authoredcontent
ms.openlocfilehash: 5bdf20549fccab5d644e35fdf4ce351540c8620d
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 03/06/2020
ms.locfileid: "78467425"
---
# <a name="understanding-and-handling-connection-lifetime-events-in-signalr"></a><span data-ttu-id="03a8a-103">Comprender y controlar eventos de duración de la conexión en SignalR</span><span class="sxs-lookup"><span data-stu-id="03a8a-103">Understanding and Handling Connection Lifetime Events in SignalR</span></span>

[!INCLUDE [Consider ASP.NET Core SignalR](~/includes/signalr/signalr-version-disambiguation.md)]

> <span data-ttu-id="03a8a-104">En este artículo se proporciona información general sobre la conexión de Signalr, la reconexión y los eventos de desconexión que se pueden controlar, y el tiempo de espera y la configuración de KeepAlive que se pueden configurar.</span><span class="sxs-lookup"><span data-stu-id="03a8a-104">This article provides an overview of the SignalR connection, reconnection, and disconnection events that you can handle, and timeout and keepalive settings that you can configure.</span></span>
>
> <span data-ttu-id="03a8a-105">En este artículo se da por supuesto que ya tiene cierto conocimiento de eventos Signalr y duración de la conexión.</span><span class="sxs-lookup"><span data-stu-id="03a8a-105">The article assumes you already have some knowledge of SignalR and connection lifetime events.</span></span> <span data-ttu-id="03a8a-106">Para obtener una introducción a Signalr, consulte [Introduction to signalr](../getting-started/introduction-to-signalr.md).</span><span class="sxs-lookup"><span data-stu-id="03a8a-106">For an introduction to SignalR, see [Introduction to SignalR](../getting-started/introduction-to-signalr.md).</span></span> <span data-ttu-id="03a8a-107">Para obtener una lista de los eventos de duración de la conexión, consulte los siguientes recursos:</span><span class="sxs-lookup"><span data-stu-id="03a8a-107">For lists of connection lifetime events, see the following resources:</span></span>
>
> - [<span data-ttu-id="03a8a-108">Cómo controlar los eventos de duración de la conexión en la clase hub</span><span class="sxs-lookup"><span data-stu-id="03a8a-108">How to handle connection lifetime events in the Hub class</span></span>](hubs-api-guide-server.md#connectionlifetime)
> - [<span data-ttu-id="03a8a-109">Cómo controlar los eventos de duración de la conexión en los clientes de JavaScript</span><span class="sxs-lookup"><span data-stu-id="03a8a-109">How to handle connection lifetime events in JavaScript clients</span></span>](hubs-api-guide-javascript-client.md#connectionlifetime)
> - [<span data-ttu-id="03a8a-110">Cómo controlar los eventos de duración de la conexión en los clientes de .NET</span><span class="sxs-lookup"><span data-stu-id="03a8a-110">How to handle connection lifetime events in .NET clients</span></span>](hubs-api-guide-net-client.md#connectionlifetime)
>
> ## <a name="software-versions-used-in-this-topic"></a><span data-ttu-id="03a8a-111">Versiones de software utilizadas en este tema</span><span class="sxs-lookup"><span data-stu-id="03a8a-111">Software versions used in this topic</span></span>
>
>
> - [<span data-ttu-id="03a8a-112">Visual Studio 2017</span><span class="sxs-lookup"><span data-stu-id="03a8a-112">Visual Studio 2017</span></span>](https://visualstudio.microsoft.com/downloads/)
> - <span data-ttu-id="03a8a-113">.NET 4.5</span><span class="sxs-lookup"><span data-stu-id="03a8a-113">.NET 4.5</span></span>
> - <span data-ttu-id="03a8a-114">Signalr versión 2</span><span class="sxs-lookup"><span data-stu-id="03a8a-114">SignalR version 2</span></span>
>
>
>
> ## <a name="previous-versions-of-this-topic"></a><span data-ttu-id="03a8a-115">Versiones anteriores de este tema</span><span class="sxs-lookup"><span data-stu-id="03a8a-115">Previous versions of this topic</span></span>
>
> <span data-ttu-id="03a8a-116">Para obtener información sobre las versiones anteriores de Signalr, consulte [versiones anteriores de signalr](../older-versions/index.md).</span><span class="sxs-lookup"><span data-stu-id="03a8a-116">For information about earlier versions of SignalR, see [SignalR Older Versions](../older-versions/index.md).</span></span>
>
> ## <a name="questions-and-comments"></a><span data-ttu-id="03a8a-117">Preguntas y comentarios</span><span class="sxs-lookup"><span data-stu-id="03a8a-117">Questions and comments</span></span>
>
> <span data-ttu-id="03a8a-118">Deje comentarios sobre cómo le gustó este tutorial y lo que podríamos mejorar en los comentarios en la parte inferior de la página.</span><span class="sxs-lookup"><span data-stu-id="03a8a-118">Please leave feedback on how you liked this tutorial and what we could improve in the comments at the bottom of the page.</span></span> <span data-ttu-id="03a8a-119">Si tiene preguntas que no están directamente relacionadas con el tutorial, puede publicarlas en el foro de [ASP.net signalr](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) o [stackoverflow.com](http://stackoverflow.com/).</span><span class="sxs-lookup"><span data-stu-id="03a8a-119">If you have questions that are not directly related to the tutorial, you can post them to the [ASP.NET SignalR forum](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) or [StackOverflow.com](http://stackoverflow.com/).</span></span>

## <a name="overview"></a><span data-ttu-id="03a8a-120">Información general</span><span class="sxs-lookup"><span data-stu-id="03a8a-120">Overview</span></span>

<span data-ttu-id="03a8a-121">Este artículo contiene las siguientes secciones:</span><span class="sxs-lookup"><span data-stu-id="03a8a-121">This article contains the following sections:</span></span>

- [<span data-ttu-id="03a8a-122">Terminología y escenarios de la duración de la conexión</span><span class="sxs-lookup"><span data-stu-id="03a8a-122">Connection lifetime terminology and scenarios</span></span>](#terminology)

    - [<span data-ttu-id="03a8a-123">Conexiones de signalr, conexiones de transporte y conexiones físicas</span><span class="sxs-lookup"><span data-stu-id="03a8a-123">SignalR connections, transport connections, and physical connections</span></span>](#signalrvstransport)
    - [<span data-ttu-id="03a8a-124">Escenarios de desconexión de transporte</span><span class="sxs-lookup"><span data-stu-id="03a8a-124">Transport disconnection scenarios</span></span>](#transportdisconnect)
    - [<span data-ttu-id="03a8a-125">Escenarios de desconexión de cliente</span><span class="sxs-lookup"><span data-stu-id="03a8a-125">Client disconnection scenarios</span></span>](#clientdisconnect)
    - [<span data-ttu-id="03a8a-126">Escenarios de desconexión del servidor</span><span class="sxs-lookup"><span data-stu-id="03a8a-126">Server disconnection scenarios</span></span>](#serverdisconnect)
- [<span data-ttu-id="03a8a-127">Configuración de tiempo de espera y keepalive</span><span class="sxs-lookup"><span data-stu-id="03a8a-127">Timeout and keepalive settings</span></span>](#timeoutkeepalive)

    - [<span data-ttu-id="03a8a-128">ConnectionTimeout</span><span class="sxs-lookup"><span data-stu-id="03a8a-128">ConnectionTimeout</span></span>](#connectiontimeout)
    - [<span data-ttu-id="03a8a-129">DisconnectTimeout</span><span class="sxs-lookup"><span data-stu-id="03a8a-129">DisconnectTimeout</span></span>](#disconnecttimeout)
    - [<span data-ttu-id="03a8a-130">KeepAlive</span><span class="sxs-lookup"><span data-stu-id="03a8a-130">KeepAlive</span></span>](#keepalive)
    - [<span data-ttu-id="03a8a-131">Cómo cambiar la configuración de tiempo de espera y keepalive</span><span class="sxs-lookup"><span data-stu-id="03a8a-131">How to change timeout and keepalive settings</span></span>](#changetimeout)
- [<span data-ttu-id="03a8a-132">Cómo notificar a los usuarios las desconexiones</span><span class="sxs-lookup"><span data-stu-id="03a8a-132">How to notify the user about disconnections</span></span>](#notifydisconnect)
- [<span data-ttu-id="03a8a-133">Cómo volver a conectar continuamente</span><span class="sxs-lookup"><span data-stu-id="03a8a-133">How to continuously reconnect</span></span>](#continuousreconnect)
- [<span data-ttu-id="03a8a-134">Cómo desconectar un cliente en el código del servidor</span><span class="sxs-lookup"><span data-stu-id="03a8a-134">How to disconnect a client in server code</span></span>](#disconnectclientfromserver)
- [<span data-ttu-id="03a8a-135">Detección del motivo de una desconexión</span><span class="sxs-lookup"><span data-stu-id="03a8a-135">Detecting the reason for a disconnection</span></span>](#detectingreasonfordisconnection)

<span data-ttu-id="03a8a-136">Los vínculos a los temas de referencia de la API se redirigen a la versión .NET 4,5 de la API.</span><span class="sxs-lookup"><span data-stu-id="03a8a-136">Links to API Reference topics are to the .NET 4.5 version of the API.</span></span> <span data-ttu-id="03a8a-137">Si usa .NET 4, vea [la versión .net 4 de los temas de la API](https://msdn.microsoft.com/library/jj891075(v=vs.100).aspx).</span><span class="sxs-lookup"><span data-stu-id="03a8a-137">If you're using .NET 4, see [the .NET 4 version of the API topics](https://msdn.microsoft.com/library/jj891075(v=vs.100).aspx).</span></span>

<a id="terminology"></a>

## <a name="connection-lifetime-terminology-and-scenarios"></a><span data-ttu-id="03a8a-138">Terminología y escenarios de la duración de la conexión</span><span class="sxs-lookup"><span data-stu-id="03a8a-138">Connection lifetime terminology and scenarios</span></span>

<span data-ttu-id="03a8a-139">El controlador de eventos `OnReconnected` de un concentrador Signalr puede ejecutarse directamente después de `OnConnected` pero no después de `OnDisconnected` para un cliente determinado.</span><span class="sxs-lookup"><span data-stu-id="03a8a-139">The `OnReconnected` event handler in a SignalR Hub can execute directly after `OnConnected` but not after `OnDisconnected` for a given client.</span></span> <span data-ttu-id="03a8a-140">La razón por la que puede tener una reconexión sin una desconexión es que hay varias maneras en las que se usa la palabra "conexión" en Signalr.</span><span class="sxs-lookup"><span data-stu-id="03a8a-140">The reason you can have a reconnection without a disconnection is that there are several ways in which the word "connection" is used in SignalR.</span></span>

<a id="signalrvstransport"></a>

### <a name="signalr-connections-transport-connections-and-physical-connections"></a><span data-ttu-id="03a8a-141">Conexiones de signalr, conexiones de transporte y conexiones físicas</span><span class="sxs-lookup"><span data-stu-id="03a8a-141">SignalR connections, transport connections, and physical connections</span></span>

<span data-ttu-id="03a8a-142">En este artículo se diferenciarán las conexiones de *signalr*, *las conexiones de transporte*y *las conexiones físicas*:</span><span class="sxs-lookup"><span data-stu-id="03a8a-142">This article will differentiate between *SignalR connections*, *transport connections*, and *physical connections*:</span></span>

- <span data-ttu-id="03a8a-143">**Signalr Connection** hace referencia a una relación lógica entre un cliente y una dirección URL del servidor, que mantiene la API de signalr y que se identifica de forma única mediante un identificador de conexión.</span><span class="sxs-lookup"><span data-stu-id="03a8a-143">**SignalR connection** refers to a logical relationship between a client and a server URL, maintained by the SignalR API and uniquely identified by a connection ID.</span></span> <span data-ttu-id="03a8a-144">Signalr mantiene los datos sobre esta relación y se utiliza para establecer una conexión de transporte.</span><span class="sxs-lookup"><span data-stu-id="03a8a-144">The data about this relationship is maintained by SignalR and is used to establish a transport connection.</span></span> <span data-ttu-id="03a8a-145">La relación finaliza y el señalizador desecha los datos cuando el cliente llama al método `Stop` o se alcanza un límite de tiempo de espera mientras Signalr está intentando volver a establecer una conexión de transporte perdida.</span><span class="sxs-lookup"><span data-stu-id="03a8a-145">The relationship ends and SignalR disposes of the data when the client calls the `Stop` method or a timeout limit is reached while SignalR is attempting to re-establish a lost transport connection.</span></span>
- <span data-ttu-id="03a8a-146">La **conexión de transporte** hace referencia a una relación lógica entre un cliente y un servidor, que se mantiene en una de las cuatro API de transporte: WebSockets, eventos enviados por el servidor, tiempo suficiente o sondeo largo.</span><span class="sxs-lookup"><span data-stu-id="03a8a-146">**Transport connection** refers to a logical relationship between a client and a server, maintained by one of the four transport APIs: WebSockets, server-sent events, forever frame, or long polling.</span></span> <span data-ttu-id="03a8a-147">Signalr usa la API de transporte para crear una conexión de transporte, y la API de transporte depende de la existencia de una conexión de red física para crear la conexión de transporte.</span><span class="sxs-lookup"><span data-stu-id="03a8a-147">SignalR uses the transport API to create a transport connection, and the transport API depends on the existence of a physical network connection to create the transport connection.</span></span> <span data-ttu-id="03a8a-148">La conexión de transporte finaliza cuando Signalr la termina o cuando la API de transporte detecta que se ha interrumpido la conexión física.</span><span class="sxs-lookup"><span data-stu-id="03a8a-148">The transport connection ends when SignalR terminates it or when the transport API detects that the physical connection is broken.</span></span>
- <span data-ttu-id="03a8a-149">**Conexión física** hace referencia a los vínculos de red física: hilos, señales inalámbricas, enrutadores, etc., que facilitan la comunicación entre un equipo cliente y un equipo servidor.</span><span class="sxs-lookup"><span data-stu-id="03a8a-149">**Physical connection** refers to the physical network links -- wires, wireless signals, routers, etc. -- that facilitate communication between a client computer and a server computer.</span></span> <span data-ttu-id="03a8a-150">La conexión física debe estar presente con el fin de establecer una conexión de transporte, y se debe establecer una conexión de transporte para establecer una conexión Signalr.</span><span class="sxs-lookup"><span data-stu-id="03a8a-150">The physical connection must be present in order to establish a transport connection, and a transport connection must be established in order to establish a SignalR connection.</span></span> <span data-ttu-id="03a8a-151">Sin embargo, interrumpir la conexión física no siempre finaliza inmediatamente la conexión de transporte o la conexión de Signalr, como se explicará más adelante en este tema.</span><span class="sxs-lookup"><span data-stu-id="03a8a-151">However, breaking the physical connection doesn't always immediately end the transport connection or the SignalR connection, as will be explained later in this topic.</span></span>

<span data-ttu-id="03a8a-152">En el diagrama siguiente, la conexión Signalr está representada por la capa hubs API y PersistentConnection API Signalr, la conexión de transporte está representada por la capa de transportes y la conexión física se representa mediante las líneas entre el servidor y los clientes de.</span><span class="sxs-lookup"><span data-stu-id="03a8a-152">In the following diagram, the SignalR connection is represented by the Hubs API and PersistentConnection API SignalR layer, the transport connection is represented by the Transports layer, and the physical connection is represented by the lines between the server and the clients.</span></span>

![Diagrama de arquitectura de signalr](handling-connection-lifetime-events/_static/image1.png)

<span data-ttu-id="03a8a-154">Cuando se llama al método `Start` en un cliente de Signalr, se proporciona código de cliente de Signalr con toda la información necesaria para establecer una conexión física con un servidor.</span><span class="sxs-lookup"><span data-stu-id="03a8a-154">When you call the `Start` method in a SignalR client, you are providing SignalR client code with all the information it needs in order to establish a physical connection to a server.</span></span> <span data-ttu-id="03a8a-155">El código de cliente de signalr usa esta información para crear una solicitud HTTP y establecer una conexión física que usa uno de los cuatro métodos de transporte.</span><span class="sxs-lookup"><span data-stu-id="03a8a-155">SignalR client code uses this information to make an HTTP request and establish a physical connection that uses one of the four transport methods.</span></span> <span data-ttu-id="03a8a-156">Si se produce un error en la conexión de transporte o se produce un error en el servidor, la conexión de Signalr no desaparecerá inmediatamente porque el cliente todavía tiene la información necesaria para volver a establecer automáticamente una nueva conexión de transporte a la misma dirección URL de Signalr.</span><span class="sxs-lookup"><span data-stu-id="03a8a-156">If the transport connection fails or the server fails, the SignalR connection doesn't go away immediately because the client still has the information it needs to automatically re-establish a new transport connection to the same SignalR URL.</span></span> <span data-ttu-id="03a8a-157">En este escenario, no interviene la intervención de la aplicación de usuario y, cuando el código de cliente de Signalr establece una nueva conexión de transporte, no inicia una nueva conexión de Signalr.</span><span class="sxs-lookup"><span data-stu-id="03a8a-157">In this scenario, no intervention from the user application is involved, and when the SignalR client code establishes a new transport connection, it does not start a new SignalR connection.</span></span> <span data-ttu-id="03a8a-158">La continuidad de la conexión Signalr se refleja en el hecho de que el identificador de conexión, que se crea cuando se llama al método `Start`, no cambia.</span><span class="sxs-lookup"><span data-stu-id="03a8a-158">The continuity of the SignalR connection is reflected in the fact that the connection ID, which is created when you call the `Start` method, does not change.</span></span>

<span data-ttu-id="03a8a-159">El controlador de eventos `OnReconnected` en el concentrador se ejecuta cuando se restablece automáticamente una conexión de transporte después de haberse perdido.</span><span class="sxs-lookup"><span data-stu-id="03a8a-159">The `OnReconnected` event handler on the Hub executes when a transport connection is automatically re-established after having been lost.</span></span> <span data-ttu-id="03a8a-160">El controlador de eventos `OnDisconnected` se ejecuta al final de una conexión Signalr.</span><span class="sxs-lookup"><span data-stu-id="03a8a-160">The `OnDisconnected` event handler executes at the end of a SignalR connection.</span></span> <span data-ttu-id="03a8a-161">Una conexión Signalr puede finalizar de cualquiera de las siguientes maneras:</span><span class="sxs-lookup"><span data-stu-id="03a8a-161">A SignalR connection can end in any of the following ways:</span></span>

- <span data-ttu-id="03a8a-162">Si el cliente llama al método `Stop`, se envía un mensaje de detención al servidor y el cliente y el servidor finalizan la conexión de Signalr inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="03a8a-162">If the client calls the `Stop` method, a stop message is sent to the server, and both client and server end the SignalR connection immediately.</span></span>
- <span data-ttu-id="03a8a-163">Una vez que se pierde la conectividad entre el cliente y el servidor, el cliente intenta volver a conectarse y el servidor espera a que el cliente vuelva a conectarse.</span><span class="sxs-lookup"><span data-stu-id="03a8a-163">After connectivity between client and server is lost, the client tries to reconnect and the server waits for the client to reconnect.</span></span> <span data-ttu-id="03a8a-164">Si los intentos de reconexión no son correctos y el tiempo de espera de la desconexión finaliza, el cliente y el servidor finalizan la conexión de Signalr.</span><span class="sxs-lookup"><span data-stu-id="03a8a-164">If the attempts to reconnect are unsuccessful and the disconnect timeout period ends, both client and server end the SignalR connection.</span></span> <span data-ttu-id="03a8a-165">El cliente deja de intentar la reconexión y el servidor desecha su representación de la conexión de Signalr.</span><span class="sxs-lookup"><span data-stu-id="03a8a-165">The client stops trying to reconnect, and the server disposes of its representation of the SignalR connection.</span></span>
- <span data-ttu-id="03a8a-166">Si el cliente deja de ejecutarse sin tener la oportunidad de llamar al método `Stop`, el servidor espera a que el cliente vuelva a conectarse y, a continuación, finaliza la conexión de Signalr después del tiempo de espera de la desconexión.</span><span class="sxs-lookup"><span data-stu-id="03a8a-166">If the client stops running without having a chance to call the `Stop` method, the server waits for the client to reconnect, and then ends the SignalR connection after the disconnect timeout period.</span></span>
- <span data-ttu-id="03a8a-167">Si el servidor deja de ejecutarse, el cliente intenta volver a conectarse (vuelve a crear la conexión de transporte) y, a continuación, finaliza la conexión de Signalr después del tiempo de espera de la desconexión.</span><span class="sxs-lookup"><span data-stu-id="03a8a-167">If the server stops running, the client tries to reconnect (re-create the transport connection), and then ends the SignalR connection after the disconnect timeout period.</span></span>

<span data-ttu-id="03a8a-168">Cuando no hay ningún problema de conexión y la aplicación de usuario finaliza la conexión de Signalr llamando al método `Stop`, la conexión de Signalr y la conexión de transporte comienzan y terminan aproximadamente al mismo tiempo.</span><span class="sxs-lookup"><span data-stu-id="03a8a-168">When there are no connection problems, and the user application ends the SignalR connection by calling the `Stop` method, the SignalR connection and the transport connection begin and end at about the same time.</span></span> <span data-ttu-id="03a8a-169">En las secciones siguientes se describen con más detalle los otros escenarios.</span><span class="sxs-lookup"><span data-stu-id="03a8a-169">The following sections describe in more detail the other scenarios.</span></span>

<a id="transportdisconnect"></a>

### <a name="transport-disconnection-scenarios"></a><span data-ttu-id="03a8a-170">Escenarios de desconexión de transporte</span><span class="sxs-lookup"><span data-stu-id="03a8a-170">Transport disconnection scenarios</span></span>

<span data-ttu-id="03a8a-171">Las conexiones físicas pueden ser lentas o podría haber interrupciones en la conectividad.</span><span class="sxs-lookup"><span data-stu-id="03a8a-171">Physical connections might be slow or there might be interruptions in connectivity.</span></span> <span data-ttu-id="03a8a-172">Dependiendo de factores como la duración de la interrupción, es posible que se quite la conexión de transporte.</span><span class="sxs-lookup"><span data-stu-id="03a8a-172">Depending on factors such as the length of the interruption, the transport connection might be dropped.</span></span> <span data-ttu-id="03a8a-173">Signalr intenta volver a establecer la conexión de transporte.</span><span class="sxs-lookup"><span data-stu-id="03a8a-173">SignalR then tries to re-establish the transport connection.</span></span> <span data-ttu-id="03a8a-174">A veces, la API de conexión de transporte detecta la interrupción y quita la conexión de transporte, y Signalr averigua inmediatamente que se ha perdido la conexión.</span><span class="sxs-lookup"><span data-stu-id="03a8a-174">Sometimes the transport connection API detects the interruption and drops the transport connection, and SignalR finds out immediately that the connection is lost.</span></span> <span data-ttu-id="03a8a-175">En otros escenarios, ni la API de conexión de transporte ni Signalr se reconocen inmediatamente que se ha perdido la conectividad.</span><span class="sxs-lookup"><span data-stu-id="03a8a-175">In other scenarios, neither the transport connection API nor SignalR becomes aware immediately that connectivity has been lost.</span></span> <span data-ttu-id="03a8a-176">En el caso de todos los transportes excepto el sondeo largo, el cliente de Signalr usa una función llamada *KeepAlive* para comprobar la pérdida de conectividad que la API de transporte no puede detectar.</span><span class="sxs-lookup"><span data-stu-id="03a8a-176">For all transports except long polling, the SignalR client uses a function called *keepalive* to check for loss of connectivity that the transport API is unable to detect.</span></span> <span data-ttu-id="03a8a-177">Para obtener información acerca de las conexiones de sondeo prolongado, vea [configuración de tiempo de espera y keepalive](#timeoutkeepalive) más adelante en este tema.</span><span class="sxs-lookup"><span data-stu-id="03a8a-177">For information about long polling connections, see [Timeout and keepalive settings](#timeoutkeepalive) later in this topic.</span></span>

<span data-ttu-id="03a8a-178">Cuando una conexión está inactiva, el servidor envía periódicamente un paquete keepalive al cliente.</span><span class="sxs-lookup"><span data-stu-id="03a8a-178">When a connection is inactive, periodically the server sends a keepalive packet to the client.</span></span> <span data-ttu-id="03a8a-179">A partir de la fecha en que se escribe este artículo, la frecuencia predeterminada es cada 10 segundos.</span><span class="sxs-lookup"><span data-stu-id="03a8a-179">As of the date this article is being written, the default frequency is every 10 seconds.</span></span> <span data-ttu-id="03a8a-180">Al escuchar estos paquetes, los clientes pueden saber si hay un problema de conexión.</span><span class="sxs-lookup"><span data-stu-id="03a8a-180">By listening for these packets, clients can tell if there is a connection problem.</span></span> <span data-ttu-id="03a8a-181">Si no se recibe un paquete keepalive cuando se espera, el cliente supone que hay problemas de conexión, como lentitud o interrupciones, después de un breve período de tiempo.</span><span class="sxs-lookup"><span data-stu-id="03a8a-181">If a keepalive packet is not received when expected, after a short time the client assumes that there are connection problems such as slowness or interruptions.</span></span> <span data-ttu-id="03a8a-182">Si el keepalive todavía no se recibe después de un tiempo más largo, el cliente asume que se ha quitado la conexión y comienza a intentar la reconexión.</span><span class="sxs-lookup"><span data-stu-id="03a8a-182">If the keepalive is still not received after a longer time, the client assumes that the connection has been dropped, and it begins trying to reconnect.</span></span>

<span data-ttu-id="03a8a-183">En el diagrama siguiente se muestran los eventos de cliente y de servidor que se producen en un escenario típico cuando hay problemas con la conexión física que la API de transporte no reconoce inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="03a8a-183">The following diagram illustrates the client and server events that are raised in a typical scenario when there are problems with the physical connection that aren't immediately recognized by the transport API.</span></span> <span data-ttu-id="03a8a-184">El diagrama se aplica a las siguientes circunstancias:</span><span class="sxs-lookup"><span data-stu-id="03a8a-184">The diagram applies to the following circumstances:</span></span>

- <span data-ttu-id="03a8a-185">El transporte es WebSockets, Forever o eventos enviados por el servidor.</span><span class="sxs-lookup"><span data-stu-id="03a8a-185">The transport is WebSockets, forever frame, or server-sent events.</span></span>
- <span data-ttu-id="03a8a-186">Hay distintos períodos de interrupción en la conexión de red física.</span><span class="sxs-lookup"><span data-stu-id="03a8a-186">There are varying periods of interruption in the physical network connection.</span></span>
- <span data-ttu-id="03a8a-187">La API de transporte no es consciente de las interrupciones, por lo que Signalr se basa en la funcionalidad keepalive para detectarlas.</span><span class="sxs-lookup"><span data-stu-id="03a8a-187">The transport API does not become aware of the interruptions, so SignalR relies on the keepalive functionality to detect them.</span></span>

![Desconexiones de transporte](handling-connection-lifetime-events/_static/image2.png)

<span data-ttu-id="03a8a-189">Si el cliente entra en el modo de reconexión, pero no puede establecer una conexión de transporte dentro del límite de tiempo de espera de la desconexión, el servidor finaliza la conexión de Signalr.</span><span class="sxs-lookup"><span data-stu-id="03a8a-189">If the client goes into reconnecting mode but can't establish a transport connection within the disconnect timeout limit, the server terminates the SignalR connection.</span></span> <span data-ttu-id="03a8a-190">Cuando esto sucede, el servidor ejecuta el método de `OnDisconnected` del concentrador y pone en cola un mensaje de desconexión para enviar al cliente en caso de que el cliente administre la conexión más tarde.</span><span class="sxs-lookup"><span data-stu-id="03a8a-190">When that happens, the server executes the Hub's `OnDisconnected` method and queues up a disconnect message to send to the client in case the client manages to connect later.</span></span> <span data-ttu-id="03a8a-191">Si el cliente se vuelve a conectar, recibe el comando Disconnect y llama al método `Stop`.</span><span class="sxs-lookup"><span data-stu-id="03a8a-191">If the client then does reconnect, it receives the disconnect command and calls the `Stop` method.</span></span> <span data-ttu-id="03a8a-192">En este escenario, `OnReconnected` no se ejecuta cuando el cliente se vuelve a conectar y `OnDisconnected` no se ejecuta cuando el cliente llama a `Stop`.</span><span class="sxs-lookup"><span data-stu-id="03a8a-192">In this scenario, `OnReconnected` is not executed when the client reconnects, and `OnDisconnected` is not executed when the client calls `Stop`.</span></span> <span data-ttu-id="03a8a-193">En el siguiente diagrama se ilustra este escenario.</span><span class="sxs-lookup"><span data-stu-id="03a8a-193">The following diagram illustrates this scenario.</span></span>

![Interrupciones de transporte: tiempo de espera del servidor](handling-connection-lifetime-events/_static/image3.png)

<span data-ttu-id="03a8a-195">Los eventos de duración de conexión de Signalr que se pueden producir en el cliente son los siguientes:</span><span class="sxs-lookup"><span data-stu-id="03a8a-195">The SignalR connection lifetime events that may be raised on the client are the following:</span></span>

- <span data-ttu-id="03a8a-196">`ConnectionSlow` evento de cliente.</span><span class="sxs-lookup"><span data-stu-id="03a8a-196">`ConnectionSlow` client event.</span></span>

    <span data-ttu-id="03a8a-197">Se genera cuando se ha pasado una proporción preestablecida del tiempo de espera de KeepAlive desde que se recibió el último mensaje o el ping keepalive.</span><span class="sxs-lookup"><span data-stu-id="03a8a-197">Raised when a preset proportion of the keepalive timeout period has passed since the last message or keepalive ping was received.</span></span> <span data-ttu-id="03a8a-198">El período de advertencia predeterminado de tiempo de espera de KeepAlive es 2/3 del tiempo de espera de KeepAlive.</span><span class="sxs-lookup"><span data-stu-id="03a8a-198">The default keepalive timeout warning period is 2/3 of the keepalive timeout.</span></span> <span data-ttu-id="03a8a-199">El tiempo de espera de KeepAlive es de 20 segundos, por lo que la advertencia se produce en unos 13 segundos.</span><span class="sxs-lookup"><span data-stu-id="03a8a-199">The keepalive timeout is 20 seconds, so the warning occurs at about 13 seconds.</span></span>

    <span data-ttu-id="03a8a-200">De forma predeterminada, el servidor envía pings de keepalive cada 10 segundos y el cliente comprueba los pings de keepalive cada 2 segundos (un tercio de la diferencia entre el valor de tiempo de espera de KeepAlive y el valor de advertencia de tiempo de espera de KeepAlive).</span><span class="sxs-lookup"><span data-stu-id="03a8a-200">By default, the server sends keepalive pings every 10 seconds, and the client checks for keepalive pings about every 2 seconds (one third of the difference between the keepalive timeout value and the keepalive timeout warning value).</span></span>

    <span data-ttu-id="03a8a-201">Si la API de transporte es consciente de una desconexión, es posible que Signalr esté informado de la desconexión antes de que transcurra el período de advertencia de tiempo de espera de KeepAlive.</span><span class="sxs-lookup"><span data-stu-id="03a8a-201">If the transport API becomes aware of a disconnection, SignalR might be informed of the disconnection before the keepalive timeout warning period passes.</span></span> <span data-ttu-id="03a8a-202">En ese caso, no se produciría el evento `ConnectionSlow`, y Signalr irá directamente al evento `Reconnecting`.</span><span class="sxs-lookup"><span data-stu-id="03a8a-202">In that case, the `ConnectionSlow` event would not be raised, and SignalR would go directly to the `Reconnecting` event.</span></span>
- <span data-ttu-id="03a8a-203">`Reconnecting` evento de cliente.</span><span class="sxs-lookup"><span data-stu-id="03a8a-203">`Reconnecting` client event.</span></span>

    <span data-ttu-id="03a8a-204">Se genera cuando (a) la API de transporte detecta que se ha perdido la conexión o (b) el tiempo de espera de KeepAlive ha transcurrido desde que se recibió el último mensaje o el ping de KeepAlive.</span><span class="sxs-lookup"><span data-stu-id="03a8a-204">Raised when (a) the transport API detects that the connection is lost, or (b) the keepalive timeout period has passed since the last message or keepalive ping was received.</span></span> <span data-ttu-id="03a8a-205">El código de cliente de Signalr comienza a intentar la reconexión.</span><span class="sxs-lookup"><span data-stu-id="03a8a-205">The SignalR client code begins trying to reconnect.</span></span> <span data-ttu-id="03a8a-206">Puede controlar este evento si desea que la aplicación realice alguna acción cuando se pierde una conexión de transporte.</span><span class="sxs-lookup"><span data-stu-id="03a8a-206">You can handle this event if you want your application to take some action when a transport connection is lost.</span></span> <span data-ttu-id="03a8a-207">El período predeterminado de tiempo de espera de KeepAlive es actualmente de 20 segundos.</span><span class="sxs-lookup"><span data-stu-id="03a8a-207">The default keepalive timeout period is currently 20 seconds.</span></span>

    <span data-ttu-id="03a8a-208">Si el código de cliente intenta llamar a un método de concentrador mientras Signalr está en modo de reconexión, Signalr intentará enviar el comando.</span><span class="sxs-lookup"><span data-stu-id="03a8a-208">If your client code tries to call a Hub method while SignalR is in reconnecting mode, SignalR will try to send the command.</span></span> <span data-ttu-id="03a8a-209">En la mayoría de los casos, se producirá un error en estos intentos, pero en algunas circunstancias podrían realizarse correctamente.</span><span class="sxs-lookup"><span data-stu-id="03a8a-209">Most of the time, such attempts will fail, but in some circumstances they might succeed.</span></span> <span data-ttu-id="03a8a-210">En el caso de los eventos enviados por el servidor, el marco Forever y los transportes de sondeo largos, Signalr usa dos canales de comunicación, uno que el cliente usa para enviar mensajes y otro que usa para recibir mensajes.</span><span class="sxs-lookup"><span data-stu-id="03a8a-210">For the server-sent events, forever frame, and long polling transports, SignalR uses two communication channels, one that the client uses to send messages and one that it uses to receive messages.</span></span> <span data-ttu-id="03a8a-211">El canal que se usa para recibir es el que se abre permanentemente y es el que se cierra cuando se interrumpe la conexión física.</span><span class="sxs-lookup"><span data-stu-id="03a8a-211">The channel used for receiving is the permanently open one, and that's the one that is closed when the physical connection is interrupted.</span></span> <span data-ttu-id="03a8a-212">El canal que se usa para el envío sigue estando disponible, por lo que si se restaura la conectividad física, una llamada de método desde el cliente al servidor podría ser correcta antes de que se vuelva a establecer el canal de recepción.</span><span class="sxs-lookup"><span data-stu-id="03a8a-212">The channel used for sending remains available, so if physical connectivity is restored, a method call from client to server might be successful before the receive channel is re-established.</span></span> <span data-ttu-id="03a8a-213">El valor devuelto no se recibirá hasta que Signalr vuelva a abrir el canal usado para recibir.</span><span class="sxs-lookup"><span data-stu-id="03a8a-213">The return value would not be received until SignalR re-opens the channel used for receiving.</span></span>
- <span data-ttu-id="03a8a-214">`Reconnected` evento de cliente.</span><span class="sxs-lookup"><span data-stu-id="03a8a-214">`Reconnected` client event.</span></span>

    <span data-ttu-id="03a8a-215">Se genera cuando se restablece la conexión de transporte.</span><span class="sxs-lookup"><span data-stu-id="03a8a-215">Raised when the transport connection is reestablished.</span></span> <span data-ttu-id="03a8a-216">Se ejecuta el controlador de eventos `OnReconnected` en el concentrador.</span><span class="sxs-lookup"><span data-stu-id="03a8a-216">The `OnReconnected` event handler in the Hub executes.</span></span>
- <span data-ttu-id="03a8a-217">`Closed` evento de cliente (evento de`disconnected` en JavaScript).</span><span class="sxs-lookup"><span data-stu-id="03a8a-217">`Closed` client event (`disconnected` event in JavaScript).</span></span>

    <span data-ttu-id="03a8a-218">Se genera cuando expira el tiempo de espera de la desconexión mientras el código de cliente de Signalr intenta volver a conectarse después de perder la conexión de transporte.</span><span class="sxs-lookup"><span data-stu-id="03a8a-218">Raised when the disconnect timeout period expires while the SignalR client code is trying to reconnect after losing the transport connection.</span></span> <span data-ttu-id="03a8a-219">El tiempo de espera de desconexión predeterminado es de 30 segundos.</span><span class="sxs-lookup"><span data-stu-id="03a8a-219">The default disconnect timeout is 30 seconds.</span></span> <span data-ttu-id="03a8a-220">(Este evento también se genera cuando finaliza la conexión porque se llama al método `Stop`).</span><span class="sxs-lookup"><span data-stu-id="03a8a-220">(This event is also raised when the connection ends because the `Stop` method is called.)</span></span>

<span data-ttu-id="03a8a-221">Las interrupciones de la conexión de transporte no detectadas por la API de transporte y no retrasan la recepción de ping de KeepAlive desde el servidor durante más tiempo que el período de advertencia de tiempo de espera de KeepAlive podría no provocar que se generen eventos de duración de la conexión.</span><span class="sxs-lookup"><span data-stu-id="03a8a-221">Transport connection interruptions that are not detected by the transport API and don't delay the reception of keepalive pings from the server for longer than the keepalive timeout warning period might not cause any connection lifetime events to be raised.</span></span>

<span data-ttu-id="03a8a-222">Algunos entornos de red cierran deliberadamente las conexiones inactivas, y otra función de los paquetes keepalive es ayudar a evitar esto permitiendo que estas redes sepan que se está usando una conexión Signalr.</span><span class="sxs-lookup"><span data-stu-id="03a8a-222">Some network environments deliberately close idle connections, and another function of the keepalive packets is to help prevent this by letting these networks know that a SignalR connection is in use.</span></span> <span data-ttu-id="03a8a-223">En casos extremos, la frecuencia predeterminada de los pings keepalive podría no ser suficiente para evitar conexiones cerradas.</span><span class="sxs-lookup"><span data-stu-id="03a8a-223">In extreme cases the default frequency of keepalive pings might not be enough to prevent closed connections.</span></span> <span data-ttu-id="03a8a-224">En ese caso, puede configurar los pings keepalive para que se envíen con más frecuencia.</span><span class="sxs-lookup"><span data-stu-id="03a8a-224">In that case you can configure keepalive pings to be sent more often.</span></span> <span data-ttu-id="03a8a-225">Para obtener más información, vea [configuración de tiempo de espera y keepalive](#timeoutkeepalive) más adelante en este tema.</span><span class="sxs-lookup"><span data-stu-id="03a8a-225">For more information, see [Timeout and keepalive settings](#timeoutkeepalive) later in this topic.</span></span>

> [!NOTE]
>
> <span data-ttu-id="03a8a-226">**Importante**: no se garantiza la secuencia de eventos que se describen aquí.</span><span class="sxs-lookup"><span data-stu-id="03a8a-226">**Important**: The sequence of events described here is not guaranteed.</span></span> <span data-ttu-id="03a8a-227">Signalr realiza cada intento de generar eventos de duración de la conexión de forma predecible según este esquema, pero hay muchas variaciones de eventos de red y muchas maneras en las que los marcos de comunicaciones subyacentes, como las API de transporte, las controlan.</span><span class="sxs-lookup"><span data-stu-id="03a8a-227">SignalR makes every attempt to raise connection lifetime events in a predictable manner according to this scheme, but there are many variations of network events and many ways in which underlying communications frameworks such as transport APIs handle them.</span></span> <span data-ttu-id="03a8a-228">Por ejemplo, el evento `Reconnected` podría no generarse cuando el cliente se vuelve a conectar o el controlador de `OnConnected` en el servidor puede ejecutarse cuando el intento de establecer una conexión no se realiza correctamente.</span><span class="sxs-lookup"><span data-stu-id="03a8a-228">For example, the `Reconnected` event might not be raised when the client reconnects, or the `OnConnected` handler on the server might run when the attempt to establish a connection is unsuccessful.</span></span> <span data-ttu-id="03a8a-229">En este tema solo se describen los efectos que normalmente se producirían en determinadas circunstancias típicas.</span><span class="sxs-lookup"><span data-stu-id="03a8a-229">This topic describes only the effects that would normally be produced by certain typical circumstances.</span></span>

<a id="clientdisconnect"></a>

### <a name="client-disconnection-scenarios"></a><span data-ttu-id="03a8a-230">Escenarios de desconexión de cliente</span><span class="sxs-lookup"><span data-stu-id="03a8a-230">Client disconnection scenarios</span></span>

<span data-ttu-id="03a8a-231">En un cliente del explorador, el código de cliente de Signalr que mantiene una conexión de Signalr se ejecuta en el contexto de JavaScript de una página web.</span><span class="sxs-lookup"><span data-stu-id="03a8a-231">In a browser client, the SignalR client code that maintains a SignalR connection runs in the JavaScript context of a web page.</span></span> <span data-ttu-id="03a8a-232">Este es el motivo por el que la conexión de Signalr tiene que finalizar al navegar de una página a otra, y eso es el motivo por el que tiene varias conexiones con varios identificadores de conexión si se conecta desde varias ventanas o pestañas del explorador.</span><span class="sxs-lookup"><span data-stu-id="03a8a-232">That's why the SignalR connection has to end when you navigate from one page to another, and that's why you have multiple connections with multiple connection IDs if you connect from multiple browser windows or tabs.</span></span> <span data-ttu-id="03a8a-233">Cuando el usuario cierra una pestaña o ventana del explorador, o navega a una nueva página o actualiza la página, la conexión de Signalr finaliza inmediatamente porque el código de cliente de Signalr controla ese evento de explorador automáticamente y llama al método `Stop`.</span><span class="sxs-lookup"><span data-stu-id="03a8a-233">When the user closes a browser window or tab, or navigates to a new page or refreshes the page, the SignalR connection immediately ends because SignalR client code handles that browser event for you and calls the `Stop` method.</span></span> <span data-ttu-id="03a8a-234">En estos escenarios, o en cualquier plataforma de cliente cuando la aplicación llama al método `Stop`, el controlador de eventos `OnDisconnected` se ejecuta inmediatamente en el servidor y el cliente genera el evento `Closed` (el evento se denomina `disconnected` en JavaScript).</span><span class="sxs-lookup"><span data-stu-id="03a8a-234">In these scenarios, or in any client platform when your application calls the `Stop` method, the `OnDisconnected` event handler executes immediately on the server and the client raises the `Closed` event (the event is named `disconnected` in JavaScript).</span></span>

<span data-ttu-id="03a8a-235">Si una aplicación cliente o el equipo en el que se ejecuta se bloquea o entra en suspensión (por ejemplo, cuando el usuario cierra el equipo portátil), no se informa al servidor de lo que ha sucedido.</span><span class="sxs-lookup"><span data-stu-id="03a8a-235">If a client application or the computer that it's running on crashes or goes to sleep (for example, when the user closes the laptop), the server is not informed about what happened.</span></span> <span data-ttu-id="03a8a-236">En lo que se refiere al servidor, la pérdida del cliente podría deberse a una interrupción de la conectividad y el cliente podría estar intentando volver a conectarse.</span><span class="sxs-lookup"><span data-stu-id="03a8a-236">As far as the server knows, the loss of the client might be due to connectivity interruption and the client might be trying to reconnect.</span></span> <span data-ttu-id="03a8a-237">Por lo tanto, en estos casos, el servidor espera a proporcionar al cliente una oportunidad de volver a conectarse y `OnDisconnected` no se ejecuta hasta que expire el tiempo de espera de la desconexión (de forma predeterminada, 30 segundos).</span><span class="sxs-lookup"><span data-stu-id="03a8a-237">Therefore, in these scenarios the server waits to give the client a chance to reconnect, and `OnDisconnected` does not execute until the disconnect timeout period expires (about 30 seconds by default).</span></span> <span data-ttu-id="03a8a-238">En el siguiente diagrama se ilustra este escenario.</span><span class="sxs-lookup"><span data-stu-id="03a8a-238">The following diagram illustrates this scenario.</span></span>

![Error del equipo cliente](handling-connection-lifetime-events/_static/image4.png)

<a id="serverdisconnect"></a>

### <a name="server-disconnection-scenarios"></a><span data-ttu-id="03a8a-240">Escenarios de desconexión del servidor</span><span class="sxs-lookup"><span data-stu-id="03a8a-240">Server disconnection scenarios</span></span>

<span data-ttu-id="03a8a-241">Cuando un servidor se queda sin conexión, se reinicia, se produce un error, se recicla el dominio de la aplicación, etc.--el resultado puede ser similar a una conexión perdida, o la API de transporte y Signalr podrían saber inmediatamente que el servidor ha desaparecido, y es posible que Signalr intente volver a conectarse sin generar el evento `ConnectionSlow`.</span><span class="sxs-lookup"><span data-stu-id="03a8a-241">When a server goes offline -- it reboots, fails, the app domain recycles, etc. -- the result might be similar to a lost connection, or the transport API and SignalR might know immediately that the server is gone, and SignalR might begin trying to reconnect without raising the `ConnectionSlow` event.</span></span> <span data-ttu-id="03a8a-242">Si el cliente entra en el modo de reconexión y el servidor se recupera o se reinicia o se pone en línea un nuevo servidor antes de que expire el tiempo de espera de la desconexión, el cliente se volverá a conectar al servidor restaurado o nuevo.</span><span class="sxs-lookup"><span data-stu-id="03a8a-242">If the client goes into reconnecting mode, and if the server recovers or restarts or a new server is brought online before the disconnect timeout period expires, the client will reconnect to the restored or new server.</span></span> <span data-ttu-id="03a8a-243">En ese caso, la conexión de Signalr continúa en el cliente y se genera el evento `Reconnected`.</span><span class="sxs-lookup"><span data-stu-id="03a8a-243">In that case, the SignalR connection continues on the client and the `Reconnected` event is raised.</span></span> <span data-ttu-id="03a8a-244">En el primer servidor, nunca se ejecuta `OnDisconnected` y, en el nuevo servidor, se ejecuta `OnReconnected` aunque nunca se ejecutó `OnConnected` para ese cliente en ese servidor antes.</span><span class="sxs-lookup"><span data-stu-id="03a8a-244">On the first server, `OnDisconnected` is never executed, and on the new server, `OnReconnected` is executed although `OnConnected` was never executed for that client on that server before.</span></span> <span data-ttu-id="03a8a-245">(El efecto es el mismo si el cliente se vuelve a conectar al mismo servidor después de un reinicio o un reciclaje de dominio de aplicación, porque cuando el servidor se reinicia no tiene memoria de actividad de conexión anterior). En el diagrama siguiente se da por supuesto que la API de transporte es consciente de la conexión perdida inmediatamente, por lo que no se genera el evento `ConnectionSlow`.</span><span class="sxs-lookup"><span data-stu-id="03a8a-245">(The effect is the same if the client reconnects to the same server after a reboot or app domain recycle, because when the server restarts it has no memory of prior connection activity.) The following diagram assumes that the transport API becomes aware of the lost connection immediately, so the `ConnectionSlow` event is not raised.</span></span>

![Error y reconexión del servidor](handling-connection-lifetime-events/_static/image5.png)

<span data-ttu-id="03a8a-247">Si un servidor no está disponible dentro del período de tiempo de espera de la desconexión, la conexión de Signalr finaliza.</span><span class="sxs-lookup"><span data-stu-id="03a8a-247">If a server does not become available within the disconnect timeout period, the SignalR connection ends.</span></span> <span data-ttu-id="03a8a-248">En este escenario, el evento de `Closed` (`disconnected` en los clientes de JavaScript) se genera en el cliente, pero nunca se llama a `OnDisconnected` en el servidor.</span><span class="sxs-lookup"><span data-stu-id="03a8a-248">In this scenario, the `Closed` event (`disconnected` in JavaScript clients) is raised on the client but `OnDisconnected` is never called on the server.</span></span> <span data-ttu-id="03a8a-249">En el diagrama siguiente se da por supuesto que la API de transporte no es consciente de la conexión perdida, por lo que se detecta mediante la funcionalidad keepalive de Signalr y se genera el evento `ConnectionSlow`.</span><span class="sxs-lookup"><span data-stu-id="03a8a-249">The following diagram assumes that the transport API does not become aware of the lost connection, so it is detected by SignalR keepalive functionality and the `ConnectionSlow` event is raised.</span></span>

![Error y tiempo de espera del servidor](handling-connection-lifetime-events/_static/image6.png)

<a id="timeoutkeepalive"></a>

## <a name="timeout-and-keepalive-settings"></a><span data-ttu-id="03a8a-251">Configuración de tiempo de espera y keepalive</span><span class="sxs-lookup"><span data-stu-id="03a8a-251">Timeout and keepalive settings</span></span>

<span data-ttu-id="03a8a-252">Los valores predeterminados `ConnectionTimeout`, `DisconnectTimeout`y `KeepAlive` son adecuados para la mayoría de los escenarios, pero se pueden cambiar si su entorno tiene necesidades especiales.</span><span class="sxs-lookup"><span data-stu-id="03a8a-252">The default `ConnectionTimeout`, `DisconnectTimeout`, and `KeepAlive` values are appropriate for most scenarios but can be changed if your environment has special needs.</span></span> <span data-ttu-id="03a8a-253">Por ejemplo, si el entorno de red cierra conexiones que están inactivas durante 5 segundos, es posible que tenga que reducir el valor de KeepAlive.</span><span class="sxs-lookup"><span data-stu-id="03a8a-253">For example, if your network environment closes connections that are idle for 5 seconds, you might have to decrease the keepalive value.</span></span>

<a id="connectiontimeout"></a>

### <a name="connectiontimeout"></a><span data-ttu-id="03a8a-254">ConnectionTimeout</span><span class="sxs-lookup"><span data-stu-id="03a8a-254">ConnectionTimeout</span></span>

<span data-ttu-id="03a8a-255">Esta configuración representa la cantidad de tiempo que se debe dejar abierta una conexión de transporte y esperar una respuesta antes de cerrarla y abrir una nueva conexión.</span><span class="sxs-lookup"><span data-stu-id="03a8a-255">This setting represents the amount of time to leave a transport connection open and waiting for a response before closing it and opening a new connection.</span></span> <span data-ttu-id="03a8a-256">El valor predeterminado es 110 segundos.</span><span class="sxs-lookup"><span data-stu-id="03a8a-256">The default value is 110 seconds.</span></span>

<span data-ttu-id="03a8a-257">Esta configuración solo se aplica cuando la funcionalidad keepalive está deshabilitada, lo que normalmente se aplica solo al transporte de sondeo prolongado.</span><span class="sxs-lookup"><span data-stu-id="03a8a-257">This setting applies only when keepalive functionality is disabled, which normally applies only to the long polling transport.</span></span> <span data-ttu-id="03a8a-258">En el diagrama siguiente se ilustra el efecto de esta configuración en una conexión de transporte de sondeo prolongado.</span><span class="sxs-lookup"><span data-stu-id="03a8a-258">The following diagram illustrates the effect of this setting on a long polling transport connection.</span></span>

![Conexión de transporte de sondeo largo](handling-connection-lifetime-events/_static/image7.png)

<a id="disconnecttimeout"></a>

### <a name="disconnecttimeout"></a><span data-ttu-id="03a8a-260">DisconnectTimeout</span><span class="sxs-lookup"><span data-stu-id="03a8a-260">DisconnectTimeout</span></span>

<span data-ttu-id="03a8a-261">Este valor representa la cantidad de tiempo que se esperará después de que se pierda una conexión de transporte antes de generar el evento `Disconnected`.</span><span class="sxs-lookup"><span data-stu-id="03a8a-261">This setting represents the amount of time to wait after a transport connection is lost before raising the `Disconnected` event.</span></span> <span data-ttu-id="03a8a-262">El valor predeterminado es 30 segundos.</span><span class="sxs-lookup"><span data-stu-id="03a8a-262">The default value is 30 seconds.</span></span> <span data-ttu-id="03a8a-263">Al establecer `DisconnectTimeout`, `KeepAlive` se establece automáticamente en 1/3 del valor de `DisconnectTimeout`.</span><span class="sxs-lookup"><span data-stu-id="03a8a-263">When you set `DisconnectTimeout`, `KeepAlive` is automatically set to 1/3 of the `DisconnectTimeout` value.</span></span>

<a id="keepalive"></a>

### <a name="keepalive"></a><span data-ttu-id="03a8a-264">KeepAlive</span><span class="sxs-lookup"><span data-stu-id="03a8a-264">KeepAlive</span></span>

<span data-ttu-id="03a8a-265">Esta configuración representa la cantidad de tiempo que hay que esperar antes de enviar un paquete keepalive a través de una conexión inactiva.</span><span class="sxs-lookup"><span data-stu-id="03a8a-265">This setting represents the amount of time to wait before sending a keepalive packet over an idle connection.</span></span> <span data-ttu-id="03a8a-266">El valor predeterminado es 10 segundos.</span><span class="sxs-lookup"><span data-stu-id="03a8a-266">The default value is 10 seconds.</span></span> <span data-ttu-id="03a8a-267">Este valor no debe ser superior a 1/3 del valor de `DisconnectTimeout`.</span><span class="sxs-lookup"><span data-stu-id="03a8a-267">This value must not be more than 1/3 of the `DisconnectTimeout` value.</span></span>

<span data-ttu-id="03a8a-268">Si desea establecer `DisconnectTimeout` y `KeepAlive`, establezca `KeepAlive` después de `DisconnectTimeout`.</span><span class="sxs-lookup"><span data-stu-id="03a8a-268">If you want to set both `DisconnectTimeout` and `KeepAlive`, set `KeepAlive` after `DisconnectTimeout`.</span></span> <span data-ttu-id="03a8a-269">De lo contrario, se sobrescribirá el valor `KeepAlive` cuando `DisconnectTimeout` establezca automáticamente `KeepAlive` en 1/3 del valor de tiempo de espera.</span><span class="sxs-lookup"><span data-stu-id="03a8a-269">Otherwise your `KeepAlive` setting will be overwritten when `DisconnectTimeout` automatically sets `KeepAlive` to 1/3 of the timeout value.</span></span>

<span data-ttu-id="03a8a-270">Si desea deshabilitar la funcionalidad keepalive, establezca `KeepAlive` en NULL.</span><span class="sxs-lookup"><span data-stu-id="03a8a-270">If you want to disable keepalive functionality, set `KeepAlive` to null.</span></span> <span data-ttu-id="03a8a-271">La funcionalidad keepalive se deshabilita automáticamente para el transporte de sondeo prolongado.</span><span class="sxs-lookup"><span data-stu-id="03a8a-271">Keepalive functionality is automatically disabled for the long polling transport.</span></span>

<a id="changetimeout"></a>

### <a name="how-to-change-timeout-and-keepalive-settings"></a><span data-ttu-id="03a8a-272">Cómo cambiar la configuración de tiempo de espera y keepalive</span><span class="sxs-lookup"><span data-stu-id="03a8a-272">How to change timeout and keepalive settings</span></span>

<span data-ttu-id="03a8a-273">Para cambiar los valores predeterminados de estos valores, establézcalo en `Application_Start` en el archivo *global. asax* , tal como se muestra en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="03a8a-273">To change the default values for these settings, set them in `Application_Start` in your *Global.asax* file, as shown in the following example.</span></span> <span data-ttu-id="03a8a-274">Los valores que se muestran en el código de ejemplo son los mismos que los valores predeterminados.</span><span class="sxs-lookup"><span data-stu-id="03a8a-274">The values shown in the sample code are the same as the default values.</span></span>

[!code-csharp[Main](handling-connection-lifetime-events/samples/sample1.cs)]

<a id="notifydisconnect"></a>

## <a name="how-to-notify-the-user-about-disconnections"></a><span data-ttu-id="03a8a-275">Cómo notificar a los usuarios las desconexiones</span><span class="sxs-lookup"><span data-stu-id="03a8a-275">How to notify the user about disconnections</span></span>

<span data-ttu-id="03a8a-276">En algunas aplicaciones, puede que desee mostrar un mensaje al usuario cuando hay problemas de conectividad.</span><span class="sxs-lookup"><span data-stu-id="03a8a-276">In some applications you might want to display a message to the user when there are connectivity problems.</span></span> <span data-ttu-id="03a8a-277">Tiene varias opciones sobre cómo y cuándo hacerlo.</span><span class="sxs-lookup"><span data-stu-id="03a8a-277">You have several options for how and when to do this.</span></span> <span data-ttu-id="03a8a-278">Los siguientes ejemplos de código son para un cliente de JavaScript que usa el proxy generado.</span><span class="sxs-lookup"><span data-stu-id="03a8a-278">The following code samples are for a JavaScript client using the generated proxy.</span></span>

- <span data-ttu-id="03a8a-279">Controle el evento `connectionSlow` para mostrar un mensaje tan pronto como Signalr tenga en cuenta los problemas de conexión, antes de que pase al modo de reconexión.</span><span class="sxs-lookup"><span data-stu-id="03a8a-279">Handle the `connectionSlow` event to display a message as soon as SignalR is aware of connection problems, before it goes into reconnecting mode.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample2.js)]
- <span data-ttu-id="03a8a-280">Controle el evento `reconnecting` para mostrar un mensaje cuando Signalr sea consciente de una desconexión y pase al modo de reconexión.</span><span class="sxs-lookup"><span data-stu-id="03a8a-280">Handle the `reconnecting` event to display a message when SignalR is aware of a disconnection and is going into reconnecting mode.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample3.js)]
- <span data-ttu-id="03a8a-281">Controle el evento `disconnected` para mostrar un mensaje cuando se agote el tiempo de espera de un intento de reconexión. En este escenario, la única manera de volver a establecer una conexión con el servidor es reiniciar la conexión de Signalr llamando al método `Start`, que creará un nuevo identificador de conexión.</span><span class="sxs-lookup"><span data-stu-id="03a8a-281">Handle the `disconnected` event to display a message when an attempt to reconnect has timed out. In this scenario, the only way to re-establish a connection with the server again is to restart the SignalR connection by calling the `Start` method, which will create a new connection ID.</span></span> <span data-ttu-id="03a8a-282">En el ejemplo de código siguiente se usa una marca para asegurarse de que se emite la notificación solo después de un tiempo de espera de reconexión, no después de un fin normal a la conexión de Signalr que se produce al llamar al método `Stop`.</span><span class="sxs-lookup"><span data-stu-id="03a8a-282">The following code sample uses a flag to make sure that you issue the notification only after a reconnecting timeout, not after a normal end to the SignalR connection caused by calling the `Stop` method.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample4.js)]

<a id="continuousreconnect"></a>

## <a name="how-to-continuously-reconnect"></a><span data-ttu-id="03a8a-283">Cómo volver a conectar continuamente</span><span class="sxs-lookup"><span data-stu-id="03a8a-283">How to continuously reconnect</span></span>

<span data-ttu-id="03a8a-284">En algunas aplicaciones, es posible que desee volver a establecer automáticamente una conexión después de que se haya perdido y que se haya agotado el tiempo de espera para el intento de reconexión. Para ello, puede llamar al método `Start` desde el controlador de eventos de `Closed` (`disconnected` controlador de eventos en los clientes de JavaScript).</span><span class="sxs-lookup"><span data-stu-id="03a8a-284">In some applications you might want to automatically re-establish a connection after it has been lost and the attempt to reconnect has timed out. To do that, you can call the `Start` method from your `Closed` event handler (`disconnected` event handler on JavaScript clients).</span></span> <span data-ttu-id="03a8a-285">Es posible que desee esperar un período de tiempo antes de llamar a `Start` para evitar hacerlo con demasiada frecuencia cuando el servidor o la conexión física no estén disponibles.</span><span class="sxs-lookup"><span data-stu-id="03a8a-285">You might want to wait a period of time before calling `Start` in order to avoid doing this too frequently when the server or the physical connection are unavailable.</span></span> <span data-ttu-id="03a8a-286">El siguiente ejemplo de código es para un cliente de JavaScript que usa el proxy generado.</span><span class="sxs-lookup"><span data-stu-id="03a8a-286">The following code sample is for a JavaScript client using the generated proxy.</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample5.js)]

<span data-ttu-id="03a8a-287">Un problema potencial que se debe tener en cuenta en los clientes móviles es que los intentos de reconexión continua cuando el servidor o la conexión física no están disponibles pueden provocar una purga de la batería innecesaria.</span><span class="sxs-lookup"><span data-stu-id="03a8a-287">A potential problem to be aware of in mobile clients is that continuous reconnection attempts when the server or physical connection isn't available could cause unnecessary battery drain.</span></span>

<a id="disconnectclientfromserver"></a>

## <a name="how-to-disconnect-a-client-in-server-code"></a><span data-ttu-id="03a8a-288">Cómo desconectar un cliente en el código del servidor</span><span class="sxs-lookup"><span data-stu-id="03a8a-288">How to disconnect a client in server code</span></span>

<span data-ttu-id="03a8a-289">Signalr versión 2 no tiene una API de servidor integrada para desconectar a los clientes.</span><span class="sxs-lookup"><span data-stu-id="03a8a-289">SignalR version 2 does not have a built-in server API for disconnecting clients.</span></span> <span data-ttu-id="03a8a-290">Hay [planes para agregar esta funcionalidad en el futuro](https://github.com/SignalR/SignalR/issues/2101).</span><span class="sxs-lookup"><span data-stu-id="03a8a-290">There are [plans for adding this functionality in the future](https://github.com/SignalR/SignalR/issues/2101).</span></span> <span data-ttu-id="03a8a-291">En la versión actual de Signalr, la manera más sencilla de desconectar un cliente del servidor consiste en implementar un método de desconexión en el cliente y llamar a ese método desde el servidor.</span><span class="sxs-lookup"><span data-stu-id="03a8a-291">In the current SignalR release, the simplest way to disconnect a client from the server is to implement a disconnect method on the client and call that method from the server.</span></span> <span data-ttu-id="03a8a-292">En el ejemplo de código siguiente se muestra un método de desconexión para un cliente de JavaScript que usa el proxy generado.</span><span class="sxs-lookup"><span data-stu-id="03a8a-292">The following code sample shows a disconnect method for a JavaScript client using the generated proxy.</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample6.js)]

> [!WARNING]
> <span data-ttu-id="03a8a-293">Seguridad: ninguno de los métodos de desconexión de los clientes ni de la API integrada propuesta abordará el escenario de clientes con piratería que ejecutan código malintencionado, ya que los clientes pueden volver a conectarse, o el código pirata podría quitar el método `stopClient` o cambiar lo que hace.</span><span class="sxs-lookup"><span data-stu-id="03a8a-293">Security - Neither this method for disconnecting clients nor the proposed built-in API will address the scenario of hacked clients that are running malicious code, since the clients could reconnect or the hacked code might remove the `stopClient` method or change what it does.</span></span> <span data-ttu-id="03a8a-294">El lugar adecuado para implementar la protección de denegación de servicio (DOS) con estado no está en el marco de trabajo ni en el nivel de servidor, sino en la infraestructura de front-end.</span><span class="sxs-lookup"><span data-stu-id="03a8a-294">The appropriate place to implement stateful denial-of-service (DOS) protection is not in the framework or the server layer, but rather in front-end infrastructure.</span></span>

<a id="detectingreasonfordisconnection"></a>
## <a name="detecting-the-reason-for-a-disconnection"></a><span data-ttu-id="03a8a-295">Detección del motivo de una desconexión</span><span class="sxs-lookup"><span data-stu-id="03a8a-295">Detecting the reason for a disconnection</span></span>

<span data-ttu-id="03a8a-296">Signalr 2,1 agrega una sobrecarga al servidor `OnDisconnect` evento que indica si el cliente se ha desconectado deliberadamente en lugar de agotarse el tiempo de espera. El parámetro `StopCalled` es true si el cliente cerró explícitamente la conexión.</span><span class="sxs-lookup"><span data-stu-id="03a8a-296">SignalR 2.1 adds an overload to the server `OnDisconnect` event that indicates if the client deliberately disconnected rather than timing out. The `StopCalled` parameter is true if the client explicitly closed the connection.</span></span> <span data-ttu-id="03a8a-297">En JavaScript, si un error del servidor condujo al cliente para desconectarse, la información de error se pasará al cliente como `$.connection.hub.lastError`.</span><span class="sxs-lookup"><span data-stu-id="03a8a-297">In JavaScript, if a server error led the client to disconnect, the error information will be passed to the client as `$.connection.hub.lastError`.</span></span>

<span data-ttu-id="03a8a-298">**C#código de servidor: `stopCalled` parámetro**</span><span class="sxs-lookup"><span data-stu-id="03a8a-298">**C# server code: `stopCalled` parameter**</span></span>

[!code-csharp[Main](handling-connection-lifetime-events/samples/sample7.cs?highlight=1,3)]

<span data-ttu-id="03a8a-299">**Código de cliente JavaScript: acceso a `lastError` en el evento `disconnect`.**</span><span class="sxs-lookup"><span data-stu-id="03a8a-299">**JavaScript client code: accessing `lastError` in the `disconnect` event.**</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample8.js?highlight=2-3)]
