---
title: Desprotección de cargas cuyas claves se han revocado en ASP.NET Core
author: rick-anderson
description: Obtenga información sobre cómo desproteger los datos, protegidos con las claves que desde entonces han sido revocadas, en una aplicación ASP.NET Core.
ms.author: riande
ms.custom: mvc
ms.date: 10/24/2018
uid: security/data-protection/consumer-apis/dangerous-unprotect
ms.openlocfilehash: b93ab0fa650041afdfaf1ed5572cc7e081bba244
ms.sourcegitcommit: 24b1f6decbb17bb22a45166e5fdb0845c65af498
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 03/01/2019
ms.locfileid: "57062832"
---
# <a name="unprotect-payloads-whose-keys-have-been-revoked-in-aspnet-core"></a><span data-ttu-id="205f4-103">Desprotección de cargas cuyas claves se han revocado en ASP.NET Core</span><span class="sxs-lookup"><span data-stu-id="205f4-103">Unprotect payloads whose keys have been revoked in ASP.NET Core</span></span>


<a name="data-protection-consumer-apis-dangerous-unprotect"></a>

<span data-ttu-id="205f4-104">Las API de protección de datos de ASP.NET Core no están pensados principalmente para la persistencia indefinido de cargas confidenciales.</span><span class="sxs-lookup"><span data-stu-id="205f4-104">The ASP.NET Core data protection APIs are not primarily intended for indefinite persistence of confidential payloads.</span></span> <span data-ttu-id="205f4-105">Otras tecnologías como [DPAPI de Windows CNG](https://msdn.microsoft.com/library/windows/desktop/hh706794%28v=vs.85%29.aspx) y [Azure Rights Management](/rights-management/) son más adecuados para el escenario de almacenamiento ilimitada, y tienen capacidades de administración de claves seguro según corresponda.</span><span class="sxs-lookup"><span data-stu-id="205f4-105">Other technologies like [Windows CNG DPAPI](https://msdn.microsoft.com/library/windows/desktop/hh706794%28v=vs.85%29.aspx) and [Azure Rights Management](/rights-management/) are more suited to the scenario of indefinite storage, and they have correspondingly strong key management capabilities.</span></span> <span data-ttu-id="205f4-106">Es decir, no hay nada que prohíben un desarrollador del uso de las API de protección de datos de ASP.NET Core para la protección a largo plazo de los datos confidenciales.</span><span class="sxs-lookup"><span data-stu-id="205f4-106">That said, there's nothing prohibiting a developer from using the ASP.NET Core data protection APIs for long-term protection of confidential data.</span></span> <span data-ttu-id="205f4-107">Las claves no se quitan nunca de conjunto de claves, por lo que `IDataProtector.Unprotect` siempre se puede recuperar las cargas existentes siempre que las claves están disponibles y son válidos.</span><span class="sxs-lookup"><span data-stu-id="205f4-107">Keys are never removed from the key ring, so `IDataProtector.Unprotect` can always recover existing payloads as long as the keys are available and valid.</span></span>

<span data-ttu-id="205f4-108">Sin embargo, un problema se produce cuando el desarrollador intenta desproteger los datos que se ha protegido con una clave revocada, como `IDataProtector.Unprotect` se iniciará una excepción en este caso.</span><span class="sxs-lookup"><span data-stu-id="205f4-108">However, an issue arises when the developer tries to unprotect data that has been protected with a revoked key, as `IDataProtector.Unprotect` will throw an exception in this case.</span></span> <span data-ttu-id="205f4-109">Esto podría ser interesante cargas breves o temporales (por ejemplo, tokens de autenticación), que fácilmente se pueden volver a crear estos tipos de cargas por el sistema y, en el peor caso el visitante del sitio podría ser necesario volver a iniciar sesión.</span><span class="sxs-lookup"><span data-stu-id="205f4-109">This might be fine for short-lived or transient payloads (like authentication tokens), as these kinds of payloads can easily be recreated by the system, and at worst the site visitor might be required to log in again.</span></span> <span data-ttu-id="205f4-110">Pero para las cargas persistentes, tener `Unprotect` throw podría provocar la pérdida de datos inaceptable.</span><span class="sxs-lookup"><span data-stu-id="205f4-110">But for persisted payloads, having `Unprotect` throw could lead to unacceptable data loss.</span></span>

## <a name="ipersisteddataprotector"></a><span data-ttu-id="205f4-111">IPersistedDataProtector</span><span class="sxs-lookup"><span data-stu-id="205f4-111">IPersistedDataProtector</span></span>

<span data-ttu-id="205f4-112">Para admitir el escenario de permitir que las cargas que se debe desproteger aunque se produzcan revocadas claves, el sistema de protección de datos contiene un `IPersistedDataProtector` tipo.</span><span class="sxs-lookup"><span data-stu-id="205f4-112">To support the scenario of allowing payloads to be unprotected even in the face of revoked keys, the data protection system contains an `IPersistedDataProtector` type.</span></span> <span data-ttu-id="205f4-113">Para obtener una instancia de `IPersistedDataProtector`, obtener simplemente una instancia de `IDataProtector` en la forma normal y la conversión de try el `IDataProtector` a `IPersistedDataProtector`.</span><span class="sxs-lookup"><span data-stu-id="205f4-113">To get an instance of `IPersistedDataProtector`, simply get an instance of `IDataProtector` in the normal fashion and try casting the `IDataProtector` to `IPersistedDataProtector`.</span></span>

> [!NOTE]
> <span data-ttu-id="205f4-114">No todos los `IDataProtector` instancias se pueden convertir en `IPersistedDataProtector`.</span><span class="sxs-lookup"><span data-stu-id="205f4-114">Not all `IDataProtector` instances can be cast to `IPersistedDataProtector`.</span></span> <span data-ttu-id="205f4-115">Los desarrolladores deben usar la C# como operador o similar evitar las excepciones en tiempo de ejecución causados por las conversiones no válidas, y deben estar preparados para controlar el caso de error adecuadamente.</span><span class="sxs-lookup"><span data-stu-id="205f4-115">Developers should use the C# as operator or similar to avoid runtime exceptions caused by invalid casts, and they should be prepared to handle the failure case appropriately.</span></span>

<span data-ttu-id="205f4-116">`IPersistedDataProtector` expone la superficie de API siguiente:</span><span class="sxs-lookup"><span data-stu-id="205f4-116">`IPersistedDataProtector` exposes the following API surface:</span></span>

```csharp
DangerousUnprotect(byte[] protectedData, bool ignoreRevocationErrors,
     out bool requiresMigration, out bool wasRevoked) : byte[]
```

<span data-ttu-id="205f4-117">Esta API toma la carga protegida (como una matriz de bytes) y devuelve la carga no protegida.</span><span class="sxs-lookup"><span data-stu-id="205f4-117">This API takes the protected payload (as a byte array) and returns the unprotected payload.</span></span> <span data-ttu-id="205f4-118">No hay ninguna sobrecarga basada en cadena.</span><span class="sxs-lookup"><span data-stu-id="205f4-118">There's no string-based overload.</span></span> <span data-ttu-id="205f4-119">Los dos parámetros de salida son los siguientes.</span><span class="sxs-lookup"><span data-stu-id="205f4-119">The two out parameters are as follows.</span></span>

* <span data-ttu-id="205f4-120">`requiresMigration`: se establece en true si la clave utilizada para proteger esta carga ya no es la clave activa de forma predeterminada, por ejemplo, la clave utilizada para proteger esta carga es antigua y tiene una clave de revertir la operación desde tendrán lugar.</span><span class="sxs-lookup"><span data-stu-id="205f4-120">`requiresMigration`: will be set to true if the key used to protect this payload is no longer the active default key, e.g., the key used to protect this payload is old and a key rolling operation has since taken place.</span></span> <span data-ttu-id="205f4-121">El llamador que desee considerar volver a proteger la carga según sus necesidades empresariales.</span><span class="sxs-lookup"><span data-stu-id="205f4-121">The caller may wish to consider reprotecting the payload depending on their business needs.</span></span>

* <span data-ttu-id="205f4-122">`wasRevoked`: se establecerá en true si la clave utilizada para proteger esta carga se ha revocado.</span><span class="sxs-lookup"><span data-stu-id="205f4-122">`wasRevoked`: will be set to true if the key used to protect this payload was revoked.</span></span>

>[!WARNING]
> <span data-ttu-id="205f4-123">Debe extremar las precauciones al pasar `ignoreRevocationErrors: true` a la `DangerousUnprotect` método.</span><span class="sxs-lookup"><span data-stu-id="205f4-123">Exercise extreme caution when passing `ignoreRevocationErrors: true` to the `DangerousUnprotect` method.</span></span> <span data-ttu-id="205f4-124">Si después de llamar a este método la `wasRevoked` valor es true, a continuación, la clave utilizada para proteger esta carga se ha revocado y autenticidad de la carga se debe tratar como sospechosa.</span><span class="sxs-lookup"><span data-stu-id="205f4-124">If after calling this method the `wasRevoked` value is true, then the key used to protect this payload was revoked, and the payload's authenticity should be treated as suspect.</span></span> <span data-ttu-id="205f4-125">En este caso, sólo seguir funcionando en la carga no protegida si tiene cierta seguridad independiente que es auténtico, por ejemplo, que procede de una base de datos seguro en lugar de que se envían por un cliente web de confianza.</span><span class="sxs-lookup"><span data-stu-id="205f4-125">In this case, only continue operating on the unprotected payload if you have some separate assurance that it's authentic, e.g. that it's coming from a secure database rather than being sent by an untrusted web client.</span></span>

[!code-csharp[](dangerous-unprotect/samples/dangerous-unprotect.cs)]
