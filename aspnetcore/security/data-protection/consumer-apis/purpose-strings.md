---
title: Cadenas de propósito en ASP.NET Core
author: rick-anderson
description: Obtenga información sobre cómo se usan las cadenas de propósito en las API de protección de datos de ASP.NET Core.
ms.author: riande
ms.date: 10/14/2016
uid: security/data-protection/consumer-apis/purpose-strings
ms.openlocfilehash: 4c85423f8de7e4b784ae1bb304a884541df251b6
ms.sourcegitcommit: 24b1f6decbb17bb22a45166e5fdb0845c65af498
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 03/01/2019
ms.locfileid: "57051292"
---
# <a name="purpose-strings-in-aspnet-core"></a><span data-ttu-id="86279-103">Cadenas de propósito en ASP.NET Core</span><span class="sxs-lookup"><span data-stu-id="86279-103">Purpose strings in ASP.NET Core</span></span>

<a name="data-protection-consumer-apis-purposes"></a>

<span data-ttu-id="86279-104">Los componentes que consumen `IDataProtectionProvider` debe pasar un único *fines* parámetro para el `CreateProtector` método.</span><span class="sxs-lookup"><span data-stu-id="86279-104">Components which consume `IDataProtectionProvider` must pass a unique *purposes* parameter to the `CreateProtector` method.</span></span> <span data-ttu-id="86279-105">Los propósitos *parámetro* es inherente a la seguridad del sistema de protección de datos, ya que proporciona aislamiento entre los consumidores de cifrado, incluso si las claves criptográficas de raíz son los mismos.</span><span class="sxs-lookup"><span data-stu-id="86279-105">The purposes *parameter* is inherent to the security of the data protection system, as it provides isolation between cryptographic consumers, even if the root cryptographic keys are the same.</span></span>

<span data-ttu-id="86279-106">Cuando un consumidor especifica un propósito, la cadena de propósito se usa junto con las claves criptográficas de raíz para derivar subclaves criptográficas únicas a ese consumidor.</span><span class="sxs-lookup"><span data-stu-id="86279-106">When a consumer specifies a purpose, the purpose string is used along with the root cryptographic keys to derive cryptographic subkeys unique to that consumer.</span></span> <span data-ttu-id="86279-107">Esto aísla el consumidor de todos los consumidores criptográficos en la aplicación: ningún otro componente puede leer sus cargas y no se puede leer cargas de cualquier otro componente.</span><span class="sxs-lookup"><span data-stu-id="86279-107">This isolates the consumer from all other cryptographic consumers in the application: no other component can read its payloads, and it cannot read any other component's payloads.</span></span> <span data-ttu-id="86279-108">Este aislamiento también procesa todas las categorías no es viable de ataque contra el componente.</span><span class="sxs-lookup"><span data-stu-id="86279-108">This isolation also renders infeasible entire categories of attack against the component.</span></span>

![Ejemplo de diagrama de propósito](purpose-strings/_static/purposes.png)

<span data-ttu-id="86279-110">En el diagrama anterior, `IDataProtector` instancias A y B **no** leer de la otra las cargas, solo su propia.</span><span class="sxs-lookup"><span data-stu-id="86279-110">In the diagram above, `IDataProtector` instances A and B **cannot** read each other's payloads, only their own.</span></span>

<span data-ttu-id="86279-111">La cadena de propósito no tiene que ser secreta.</span><span class="sxs-lookup"><span data-stu-id="86279-111">The purpose string doesn't have to be secret.</span></span> <span data-ttu-id="86279-112">Simplemente debe ser único en el sentido de que ningún otro componente con buen comportamiento sacarán nunca proporcionará la misma cadena de propósito.</span><span class="sxs-lookup"><span data-stu-id="86279-112">It should simply be unique in the sense that no other well-behaved component will ever provide the same purpose string.</span></span>

>[!TIP]
> <span data-ttu-id="86279-113">Con el nombre de espacio de nombres y tipo del componente de consumir las API de protección de datos es una buena regla general, al igual que en la práctica, que esta información nunca estará en conflicto.</span><span class="sxs-lookup"><span data-stu-id="86279-113">Using the namespace and type name of the component consuming the data protection APIs is a good rule of thumb, as in practice this information will never conflict.</span></span>
>
><span data-ttu-id="86279-114">Un componente creado por Contoso que se encarga de los tokens de portador de minting podría usar Contoso.Security.BearerToken como cadena de su propósito.</span><span class="sxs-lookup"><span data-stu-id="86279-114">A Contoso-authored component which is responsible for minting bearer tokens might use Contoso.Security.BearerToken as its purpose string.</span></span> <span data-ttu-id="86279-115">O - incluso mejor - usaría Contoso.Security.BearerToken.v1 como cadena de su propósito.</span><span class="sxs-lookup"><span data-stu-id="86279-115">Or - even better - it might use Contoso.Security.BearerToken.v1 as its purpose string.</span></span> <span data-ttu-id="86279-116">Anexa el número de versión permite que una versión futura usar Contoso.Security.BearerToken.v2 como su propósito y las distintas versiones sería completamente aisladas entre sí como cargas útiles de ir.</span><span class="sxs-lookup"><span data-stu-id="86279-116">Appending the version number allows a future version to use Contoso.Security.BearerToken.v2 as its purpose, and the different versions would be completely isolated from one another as far as payloads go.</span></span>

<span data-ttu-id="86279-117">Desde el parámetro de fines `CreateProtector` es una matriz de cadenas, lo anterior se haya en su lugar, especificado como `[ "Contoso.Security.BearerToken", "v1" ]`.</span><span class="sxs-lookup"><span data-stu-id="86279-117">Since the purposes parameter to `CreateProtector` is a string array, the above could've been instead specified as `[ "Contoso.Security.BearerToken", "v1" ]`.</span></span> <span data-ttu-id="86279-118">Esto permite establecer una jerarquía de propósitos y abre la posibilidad de escenarios de varios inquilinos con el sistema de protección de datos.</span><span class="sxs-lookup"><span data-stu-id="86279-118">This allows establishing a hierarchy of purposes and opens up the possibility of multi-tenancy scenarios with the data protection system.</span></span>

<a name="data-protection-contoso-purpose"></a>

>[!WARNING]
> <span data-ttu-id="86279-119">Componentes no deben permitir la entrada del usuario de confianza a ser la única fuente de entrada de la cadena con fines.</span><span class="sxs-lookup"><span data-stu-id="86279-119">Components shouldn't allow untrusted user input to be the sole source of input for the purposes chain.</span></span>
>
><span data-ttu-id="86279-120">Por ejemplo, considere la posibilidad de un componente Contoso.Messaging.SecureMessage que es responsable de almacenar mensajes seguros.</span><span class="sxs-lookup"><span data-stu-id="86279-120">For example, consider a component Contoso.Messaging.SecureMessage which is responsible for storing secure messages.</span></span> <span data-ttu-id="86279-121">Si el componente de mensajería seguro llamase a `CreateProtector([ username ])`, a continuación, un usuario malintencionado podría crear una cuenta con el nombre de usuario "Contoso.Security.BearerToken" en un intento de obtener el componente para llamar a `CreateProtector([ "Contoso.Security.BearerToken" ])`, lo que accidentalmente la mensajería segura sistema de mint cargas que se podría percibir como tokens de autenticación.</span><span class="sxs-lookup"><span data-stu-id="86279-121">If the secure messaging component were to call `CreateProtector([ username ])`, then a malicious user might create an account with username "Contoso.Security.BearerToken" in an attempt to get the component to call `CreateProtector([ "Contoso.Security.BearerToken" ])`, thus inadvertently causing the secure messaging system to mint payloads that could be perceived as authentication tokens.</span></span>
>
><span data-ttu-id="86279-122">Una cadena con fines mejor para el componente de mensajería sería `CreateProtector([ "Contoso.Messaging.SecureMessage", "User: username" ])`, que proporciona aislamiento adecuado.</span><span class="sxs-lookup"><span data-stu-id="86279-122">A better purposes chain for the messaging component would be `CreateProtector([ "Contoso.Messaging.SecureMessage", "User: username" ])`, which provides proper isolation.</span></span>

<span data-ttu-id="86279-123">El aislamiento que ofrecen los comportamientos y `IDataProtectionProvider`, `IDataProtector`, y con fines son los siguientes:</span><span class="sxs-lookup"><span data-stu-id="86279-123">The isolation provided by and behaviors of `IDataProtectionProvider`, `IDataProtector`, and purposes are as follows:</span></span>

* <span data-ttu-id="86279-124">Para un determinado `IDataProtectionProvider` objeto, el `CreateProtector` creará un `IDataProtector` objeto vinculado de forma exclusiva a ambos el `IDataProtectionProvider` objeto que lo creó y el parámetro de efectos que se pasó al método.</span><span class="sxs-lookup"><span data-stu-id="86279-124">For a given `IDataProtectionProvider` object, the `CreateProtector` method will create an `IDataProtector` object uniquely tied to both the `IDataProtectionProvider` object which created it and the purposes parameter which was passed into the method.</span></span>

* <span data-ttu-id="86279-125">El parámetro propósito no debe ser null.</span><span class="sxs-lookup"><span data-stu-id="86279-125">The purpose parameter must not be null.</span></span> <span data-ttu-id="86279-126">(Si se especifica con fines como una matriz, esto significa que la matriz no debe ser de longitud cero y todos los elementos de la matriz deben ser distinto de null). Propósito de una cadena vacía es técnicamente válido pero en absoluto.</span><span class="sxs-lookup"><span data-stu-id="86279-126">(If purposes is specified as an array, this means that the array must not be of zero length and all elements of the array must be non-null.) An empty string purpose is technically allowed but is discouraged.</span></span>

* <span data-ttu-id="86279-127">Argumentos de dos objetivos son equivalentes si y solo si contienen las mismas cadenas (utilizando a un comparador ordinal) en el mismo orden.</span><span class="sxs-lookup"><span data-stu-id="86279-127">Two purposes arguments are equivalent if and only if they contain the same strings (using an ordinal comparer) in the same order.</span></span> <span data-ttu-id="86279-128">Un argumento único propósito es equivalente a la matriz de fines único elemento correspondiente.</span><span class="sxs-lookup"><span data-stu-id="86279-128">A single purpose argument is equivalent to the corresponding single-element purposes array.</span></span>

* <span data-ttu-id="86279-129">Dos `IDataProtector` objetos son equivalentes si y solo si se crean desde equivalente `IDataProtectionProvider` objetos con los parámetros de fines equivalente.</span><span class="sxs-lookup"><span data-stu-id="86279-129">Two `IDataProtector` objects are equivalent if and only if they're created from equivalent `IDataProtectionProvider` objects with equivalent purposes parameters.</span></span>

* <span data-ttu-id="86279-130">Para un determinado `IDataProtector` (objeto), una llamada a `Unprotect(protectedData)` devolverá original `unprotectedData` si y solo si `protectedData := Protect(unprotectedData)` para equivalente `IDataProtector` objeto.</span><span class="sxs-lookup"><span data-stu-id="86279-130">For a given `IDataProtector` object, a call to `Unprotect(protectedData)` will return the original `unprotectedData` if and only if `protectedData := Protect(unprotectedData)` for an equivalent `IDataProtector` object.</span></span>

> [!NOTE]
> <span data-ttu-id="86279-131">No estamos considerando el caso de que algún componente intencionadamente elige una cadena de propósito que se sabe que entran en conflicto con otro componente.</span><span class="sxs-lookup"><span data-stu-id="86279-131">We're not considering the case where some component intentionally chooses a purpose string which is known to conflict with another component.</span></span> <span data-ttu-id="86279-132">Este componente básicamente se consideraría malintencionado, y este sistema no está diseñado para proporcionar garantías de seguridad en caso de que ya se está ejecutando código malintencionado dentro del proceso de trabajo.</span><span class="sxs-lookup"><span data-stu-id="86279-132">Such a component would essentially be considered malicious, and this system isn't intended to provide security guarantees in the event that malicious code is already running inside of the worker process.</span></span>
