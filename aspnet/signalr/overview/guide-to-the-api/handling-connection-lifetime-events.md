---
uid: signalr/overview/guide-to-the-api/handling-connection-lifetime-events
title: Comprender y controlar los eventos de por vida de la conexión en SignalR Microsoft Docs
author: bradygaster
description: En este artículo se describe cómo usar los eventos expuestos por la API de Concentradores.
ms.author: bradyg
ms.date: 01/15/2019
ms.assetid: 03960de2-8d95-4444-9169-4426dcc64913
msc.legacyurl: /signalr/overview/guide-to-the-api/handling-connection-lifetime-events
msc.type: authoredcontent
ms.openlocfilehash: 5bdf20549fccab5d644e35fdf4ce351540c8620d
ms.sourcegitcommit: ce28244209db8615bc9bdd576a2e2c88174d318d
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 04/06/2020
ms.locfileid: "80675830"
---
# <a name="understanding-and-handling-connection-lifetime-events-in-signalr"></a><span data-ttu-id="1da0e-103">Comprender y controlar eventos de duración de la conexión en SignalR</span><span class="sxs-lookup"><span data-stu-id="1da0e-103">Understanding and Handling Connection Lifetime Events in SignalR</span></span>

[!INCLUDE [Consider ASP.NET Core SignalR](~/includes/signalr/signalr-version-disambiguation.md)]

> <span data-ttu-id="1da0e-104">En este artículo se proporciona información general sobre los eventos de conexión, reconexión y desconexión de SignalR que puede controlar, así como los valores de tiempo de espera y keepalive que puede configurar.</span><span class="sxs-lookup"><span data-stu-id="1da0e-104">This article provides an overview of the SignalR connection, reconnection, and disconnection events that you can handle, and timeout and keepalive settings that you can configure.</span></span>
>
> <span data-ttu-id="1da0e-105">En el artículo se supone que ya tiene algún conocimiento de SignalR y eventos de duración de conexión.</span><span class="sxs-lookup"><span data-stu-id="1da0e-105">The article assumes you already have some knowledge of SignalR and connection lifetime events.</span></span> <span data-ttu-id="1da0e-106">Para obtener una introducción a SignalR, consulte [Introducción a SignalR](../getting-started/introduction-to-signalr.md).</span><span class="sxs-lookup"><span data-stu-id="1da0e-106">For an introduction to SignalR, see [Introduction to SignalR](../getting-started/introduction-to-signalr.md).</span></span> <span data-ttu-id="1da0e-107">Para obtener listas de eventos de duración de conexión, consulte los siguientes recursos:</span><span class="sxs-lookup"><span data-stu-id="1da0e-107">For lists of connection lifetime events, see the following resources:</span></span>
>
> - [<span data-ttu-id="1da0e-108">Cómo controlar los eventos de duración de la conexión en la clase Hub</span><span class="sxs-lookup"><span data-stu-id="1da0e-108">How to handle connection lifetime events in the Hub class</span></span>](hubs-api-guide-server.md#connectionlifetime)
> - [<span data-ttu-id="1da0e-109">Cómo controlar los eventos de duración de la conexión en clientes JavaScript</span><span class="sxs-lookup"><span data-stu-id="1da0e-109">How to handle connection lifetime events in JavaScript clients</span></span>](hubs-api-guide-javascript-client.md#connectionlifetime)
> - [<span data-ttu-id="1da0e-110">Cómo controlar eventos de duración de conexión en clientes .NET</span><span class="sxs-lookup"><span data-stu-id="1da0e-110">How to handle connection lifetime events in .NET clients</span></span>](hubs-api-guide-net-client.md#connectionlifetime)
>
> ## <a name="software-versions-used-in-this-topic"></a><span data-ttu-id="1da0e-111">Versiones de software utilizadas en este tema</span><span class="sxs-lookup"><span data-stu-id="1da0e-111">Software versions used in this topic</span></span>
>
>
> - [<span data-ttu-id="1da0e-112">Visual Studio 2017</span><span class="sxs-lookup"><span data-stu-id="1da0e-112">Visual Studio 2017</span></span>](https://visualstudio.microsoft.com/downloads/)
> - <span data-ttu-id="1da0e-113">.NET 4.5</span><span class="sxs-lookup"><span data-stu-id="1da0e-113">.NET 4.5</span></span>
> - <span data-ttu-id="1da0e-114">SignalR versión 2</span><span class="sxs-lookup"><span data-stu-id="1da0e-114">SignalR version 2</span></span>
>
>
>
> ## <a name="previous-versions-of-this-topic"></a><span data-ttu-id="1da0e-115">Versiones anteriores de este tema</span><span class="sxs-lookup"><span data-stu-id="1da0e-115">Previous versions of this topic</span></span>
>
> <span data-ttu-id="1da0e-116">Para obtener información acerca de las versiones anteriores de SignalR, vea [Versiones anteriores](../older-versions/index.md)de SignalR .</span><span class="sxs-lookup"><span data-stu-id="1da0e-116">For information about earlier versions of SignalR, see [SignalR Older Versions](../older-versions/index.md).</span></span>
>
> ## <a name="questions-and-comments"></a><span data-ttu-id="1da0e-117">Preguntas y comentarios</span><span class="sxs-lookup"><span data-stu-id="1da0e-117">Questions and comments</span></span>
>
> <span data-ttu-id="1da0e-118">Por favor, deje comentarios sobre cómo le gustó este tutorial y lo que podríamos mejorar en los comentarios en la parte inferior de la página.</span><span class="sxs-lookup"><span data-stu-id="1da0e-118">Please leave feedback on how you liked this tutorial and what we could improve in the comments at the bottom of the page.</span></span> <span data-ttu-id="1da0e-119">Si tiene preguntas que no están directamente relacionadas con el tutorial, puede publicarlas en el [ASP.NET foro](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) de SignalR o [StackOverflow.com](http://stackoverflow.com/).</span><span class="sxs-lookup"><span data-stu-id="1da0e-119">If you have questions that are not directly related to the tutorial, you can post them to the [ASP.NET SignalR forum](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) or [StackOverflow.com](http://stackoverflow.com/).</span></span>

## <a name="overview"></a><span data-ttu-id="1da0e-120">Información general</span><span class="sxs-lookup"><span data-stu-id="1da0e-120">Overview</span></span>

<span data-ttu-id="1da0e-121">Este artículo contiene las secciones siguientes:</span><span class="sxs-lookup"><span data-stu-id="1da0e-121">This article contains the following sections:</span></span>

- [<span data-ttu-id="1da0e-122">Terminología y escenarios de duración de la conexión</span><span class="sxs-lookup"><span data-stu-id="1da0e-122">Connection lifetime terminology and scenarios</span></span>](#terminology)

    - [<span data-ttu-id="1da0e-123">Conexiones de SignalR, conexiones de transporte y conexiones físicas</span><span class="sxs-lookup"><span data-stu-id="1da0e-123">SignalR connections, transport connections, and physical connections</span></span>](#signalrvstransport)
    - [<span data-ttu-id="1da0e-124">Escenarios de desconexión del transporte</span><span class="sxs-lookup"><span data-stu-id="1da0e-124">Transport disconnection scenarios</span></span>](#transportdisconnect)
    - [<span data-ttu-id="1da0e-125">Escenarios de desconexión del cliente</span><span class="sxs-lookup"><span data-stu-id="1da0e-125">Client disconnection scenarios</span></span>](#clientdisconnect)
    - [<span data-ttu-id="1da0e-126">Escenarios de desconexión del servidor</span><span class="sxs-lookup"><span data-stu-id="1da0e-126">Server disconnection scenarios</span></span>](#serverdisconnect)
- [<span data-ttu-id="1da0e-127">Tiempo de espera y ajustes de keepalive</span><span class="sxs-lookup"><span data-stu-id="1da0e-127">Timeout and keepalive settings</span></span>](#timeoutkeepalive)

    - [<span data-ttu-id="1da0e-128">Connectiontimeout</span><span class="sxs-lookup"><span data-stu-id="1da0e-128">ConnectionTimeout</span></span>](#connectiontimeout)
    - [<span data-ttu-id="1da0e-129">DisconnectTimeout</span><span class="sxs-lookup"><span data-stu-id="1da0e-129">DisconnectTimeout</span></span>](#disconnecttimeout)
    - [<span data-ttu-id="1da0e-130">KeepAlive</span><span class="sxs-lookup"><span data-stu-id="1da0e-130">KeepAlive</span></span>](#keepalive)
    - [<span data-ttu-id="1da0e-131">Cómo cambiar el tiempo de espera y la configuración de keepalive</span><span class="sxs-lookup"><span data-stu-id="1da0e-131">How to change timeout and keepalive settings</span></span>](#changetimeout)
- [<span data-ttu-id="1da0e-132">Cómo notificar al usuario sobre desconexiones</span><span class="sxs-lookup"><span data-stu-id="1da0e-132">How to notify the user about disconnections</span></span>](#notifydisconnect)
- [<span data-ttu-id="1da0e-133">Cómo volver a conectarse continuamente</span><span class="sxs-lookup"><span data-stu-id="1da0e-133">How to continuously reconnect</span></span>](#continuousreconnect)
- [<span data-ttu-id="1da0e-134">Cómo desconectar un cliente en el código del servidor</span><span class="sxs-lookup"><span data-stu-id="1da0e-134">How to disconnect a client in server code</span></span>](#disconnectclientfromserver)
- [<span data-ttu-id="1da0e-135">Detectar la razón de una desconexión</span><span class="sxs-lookup"><span data-stu-id="1da0e-135">Detecting the reason for a disconnection</span></span>](#detectingreasonfordisconnection)

<span data-ttu-id="1da0e-136">Los vínculos a temas de Referencia de API se vinculan a la versión 4.5 de la API.</span><span class="sxs-lookup"><span data-stu-id="1da0e-136">Links to API Reference topics are to the .NET 4.5 version of the API.</span></span> <span data-ttu-id="1da0e-137">Si usa .NET 4, consulte [la versión de .NET 4 de los temas de la API.](https://msdn.microsoft.com/library/jj891075(v=vs.100).aspx)</span><span class="sxs-lookup"><span data-stu-id="1da0e-137">If you're using .NET 4, see [the .NET 4 version of the API topics](https://msdn.microsoft.com/library/jj891075(v=vs.100).aspx).</span></span>

<a id="terminology"></a>

## <a name="connection-lifetime-terminology-and-scenarios"></a><span data-ttu-id="1da0e-138">Terminología y escenarios de duración de la conexión</span><span class="sxs-lookup"><span data-stu-id="1da0e-138">Connection lifetime terminology and scenarios</span></span>

<span data-ttu-id="1da0e-139">El `OnReconnected` controlador de eventos en un `OnConnected` concentrador de `OnDisconnected` SignalR puede ejecutarse directamente después pero no después para un cliente determinado.</span><span class="sxs-lookup"><span data-stu-id="1da0e-139">The `OnReconnected` event handler in a SignalR Hub can execute directly after `OnConnected` but not after `OnDisconnected` for a given client.</span></span> <span data-ttu-id="1da0e-140">La razón por la que puede tener una reconexión sin una desconexión es que hay varias maneras en que la palabra "conexión" se utiliza en SignalR.</span><span class="sxs-lookup"><span data-stu-id="1da0e-140">The reason you can have a reconnection without a disconnection is that there are several ways in which the word "connection" is used in SignalR.</span></span>

<a id="signalrvstransport"></a>

### <a name="signalr-connections-transport-connections-and-physical-connections"></a><span data-ttu-id="1da0e-141">Conexiones de SignalR, conexiones de transporte y conexiones físicas</span><span class="sxs-lookup"><span data-stu-id="1da0e-141">SignalR connections, transport connections, and physical connections</span></span>

<span data-ttu-id="1da0e-142">Este artículo diferenciará entre *conexiones de SignalR,* *conexiones*de transporte y *conexiones físicas:*</span><span class="sxs-lookup"><span data-stu-id="1da0e-142">This article will differentiate between *SignalR connections*, *transport connections*, and *physical connections*:</span></span>

- <span data-ttu-id="1da0e-143">**La conexión de SignalR** hace referencia a una relación lógica entre un cliente y una dirección URL de servidor, mantenida por la API de SignalR e identificada de forma exclusiva por un identificador de conexión.</span><span class="sxs-lookup"><span data-stu-id="1da0e-143">**SignalR connection** refers to a logical relationship between a client and a server URL, maintained by the SignalR API and uniquely identified by a connection ID.</span></span> <span data-ttu-id="1da0e-144">SignalR mantiene los datos sobre esta relación y se utiliza para establecer una conexión de transporte.</span><span class="sxs-lookup"><span data-stu-id="1da0e-144">The data about this relationship is maintained by SignalR and is used to establish a transport connection.</span></span> <span data-ttu-id="1da0e-145">La relación finaliza y SignalR elimina los datos `Stop` cuando el cliente llama al método o se alcanza un límite de tiempo de espera mientras SignalR intenta restablecer una conexión de transporte perdida.</span><span class="sxs-lookup"><span data-stu-id="1da0e-145">The relationship ends and SignalR disposes of the data when the client calls the `Stop` method or a timeout limit is reached while SignalR is attempting to re-establish a lost transport connection.</span></span>
- <span data-ttu-id="1da0e-146">**La conexión** de transporte hace referencia a una relación lógica entre un cliente y un servidor, mantenida por una de las cuatro API de transporte: WebSockets, eventos enviados por el servidor, marco para siempre o sondeo largo.</span><span class="sxs-lookup"><span data-stu-id="1da0e-146">**Transport connection** refers to a logical relationship between a client and a server, maintained by one of the four transport APIs: WebSockets, server-sent events, forever frame, or long polling.</span></span> <span data-ttu-id="1da0e-147">SignalR usa la API de transporte para crear una conexión de transporte y la API de transporte depende de la existencia de una conexión de red física para crear la conexión de transporte.</span><span class="sxs-lookup"><span data-stu-id="1da0e-147">SignalR uses the transport API to create a transport connection, and the transport API depends on the existence of a physical network connection to create the transport connection.</span></span> <span data-ttu-id="1da0e-148">La conexión de transporte finaliza cuando SignalR la termina o cuando la API de transporte detecta que la conexión física está interrumpida.</span><span class="sxs-lookup"><span data-stu-id="1da0e-148">The transport connection ends when SignalR terminates it or when the transport API detects that the physical connection is broken.</span></span>
- <span data-ttu-id="1da0e-149">**La conexión física** se refiere a los enlaces de red física -- cables, señales inalámbricas, enrutadores, etc.- que facilitan la comunicación entre un equipo cliente y un equipo servidor.</span><span class="sxs-lookup"><span data-stu-id="1da0e-149">**Physical connection** refers to the physical network links -- wires, wireless signals, routers, etc. -- that facilitate communication between a client computer and a server computer.</span></span> <span data-ttu-id="1da0e-150">La conexión física debe estar presente para establecer una conexión de transporte, y debe establecerse una conexión de transporte para establecer una conexión SignalR.</span><span class="sxs-lookup"><span data-stu-id="1da0e-150">The physical connection must be present in order to establish a transport connection, and a transport connection must be established in order to establish a SignalR connection.</span></span> <span data-ttu-id="1da0e-151">Sin embargo, interrumpir la conexión física no siempre finaliza inmediatamente la conexión de transporte o la conexión de SignalR, como se explicará más adelante en este tema.</span><span class="sxs-lookup"><span data-stu-id="1da0e-151">However, breaking the physical connection doesn't always immediately end the transport connection or the SignalR connection, as will be explained later in this topic.</span></span>

<span data-ttu-id="1da0e-152">En el diagrama siguiente, la conexión de SignalR se representa mediante la API de concentradores y la capa PersistentConnection API SignalR, la conexión de transporte se representa mediante la capa Transports y la conexión física se representa mediante las líneas entre el servidor y los clientes.</span><span class="sxs-lookup"><span data-stu-id="1da0e-152">In the following diagram, the SignalR connection is represented by the Hubs API and PersistentConnection API SignalR layer, the transport connection is represented by the Transports layer, and the physical connection is represented by the lines between the server and the clients.</span></span>

![Diagrama de arquitectura SignalR](handling-connection-lifetime-events/_static/image1.png)

<span data-ttu-id="1da0e-154">Cuando se `Start` llama al método en un cliente de SignalR, se proporciona el código de cliente de SignalR con toda la información que necesita para establecer una conexión física a un servidor.</span><span class="sxs-lookup"><span data-stu-id="1da0e-154">When you call the `Start` method in a SignalR client, you are providing SignalR client code with all the information it needs in order to establish a physical connection to a server.</span></span> <span data-ttu-id="1da0e-155">El código de cliente de SignalR utiliza esta información para realizar una solicitud HTTP y establecer una conexión física que utiliza uno de los cuatro métodos de transporte.</span><span class="sxs-lookup"><span data-stu-id="1da0e-155">SignalR client code uses this information to make an HTTP request and establish a physical connection that uses one of the four transport methods.</span></span> <span data-ttu-id="1da0e-156">Si se produce un error en la conexión de transporte o se produce un error en el servidor, la conexión de SignalR no desaparece inmediatamente porque el cliente todavía tiene la información que necesita para restablecer automáticamente una nueva conexión de transporte a la misma dirección URL de SignalR.</span><span class="sxs-lookup"><span data-stu-id="1da0e-156">If the transport connection fails or the server fails, the SignalR connection doesn't go away immediately because the client still has the information it needs to automatically re-establish a new transport connection to the same SignalR URL.</span></span> <span data-ttu-id="1da0e-157">En este escenario, no hay ninguna intervención de la aplicación de usuario implicada y cuando el código de cliente de SignalR establece una nueva conexión de transporte, no inicia una nueva conexión de SignalR.</span><span class="sxs-lookup"><span data-stu-id="1da0e-157">In this scenario, no intervention from the user application is involved, and when the SignalR client code establishes a new transport connection, it does not start a new SignalR connection.</span></span> <span data-ttu-id="1da0e-158">La continuidad de la conexión SignalR se refleja en el hecho de que `Start` el identificador de conexión, que se crea cuando se llama al método, no cambia.</span><span class="sxs-lookup"><span data-stu-id="1da0e-158">The continuity of the SignalR connection is reflected in the fact that the connection ID, which is created when you call the `Start` method, does not change.</span></span>

<span data-ttu-id="1da0e-159">El `OnReconnected` controlador de eventos en el concentrador se ejecuta cuando una conexión de transporte se restablece automáticamente después de haberse perdido.</span><span class="sxs-lookup"><span data-stu-id="1da0e-159">The `OnReconnected` event handler on the Hub executes when a transport connection is automatically re-established after having been lost.</span></span> <span data-ttu-id="1da0e-160">El `OnDisconnected` controlador de eventos se ejecuta al final de una conexión de SignalR.</span><span class="sxs-lookup"><span data-stu-id="1da0e-160">The `OnDisconnected` event handler executes at the end of a SignalR connection.</span></span> <span data-ttu-id="1da0e-161">Una conexión de SignalR puede finalizar de cualquiera de las siguientes maneras:</span><span class="sxs-lookup"><span data-stu-id="1da0e-161">A SignalR connection can end in any of the following ways:</span></span>

- <span data-ttu-id="1da0e-162">Si el cliente `Stop` llama al método, se envía un mensaje de detención al servidor y tanto el cliente como el servidor finalizan la conexión de SignalR inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="1da0e-162">If the client calls the `Stop` method, a stop message is sent to the server, and both client and server end the SignalR connection immediately.</span></span>
- <span data-ttu-id="1da0e-163">Después de que se pierda la conectividad entre el cliente y el servidor, el cliente intenta volver a conectarse y el servidor espera a que el cliente vuelva a conectarse.</span><span class="sxs-lookup"><span data-stu-id="1da0e-163">After connectivity between client and server is lost, the client tries to reconnect and the server waits for the client to reconnect.</span></span> <span data-ttu-id="1da0e-164">Si los intentos de volver a conectarse no tienen éxito y finaliza el período de tiempo de espera de desconexión, el cliente y el servidor finalizan la conexión de SignalR.</span><span class="sxs-lookup"><span data-stu-id="1da0e-164">If the attempts to reconnect are unsuccessful and the disconnect timeout period ends, both client and server end the SignalR connection.</span></span> <span data-ttu-id="1da0e-165">El cliente deja de intentar volver a conectarse y el servidor elimina su representación de la conexión de SignalR.</span><span class="sxs-lookup"><span data-stu-id="1da0e-165">The client stops trying to reconnect, and the server disposes of its representation of the SignalR connection.</span></span>
- <span data-ttu-id="1da0e-166">Si el cliente deja de ejecutarse `Stop` sin tener la oportunidad de llamar al método, el servidor espera a que el cliente se vuelva a conectar y, a continuación, finaliza la conexión de SignalR después del período de tiempo de espera de desconexión.</span><span class="sxs-lookup"><span data-stu-id="1da0e-166">If the client stops running without having a chance to call the `Stop` method, the server waits for the client to reconnect, and then ends the SignalR connection after the disconnect timeout period.</span></span>
- <span data-ttu-id="1da0e-167">Si el servidor deja de ejecutarse, el cliente intenta volver a conectarse (volver a crear la conexión de transporte) y, a continuación, finaliza la conexión de SignalR después del período de tiempo de espera de desconexión.</span><span class="sxs-lookup"><span data-stu-id="1da0e-167">If the server stops running, the client tries to reconnect (re-create the transport connection), and then ends the SignalR connection after the disconnect timeout period.</span></span>

<span data-ttu-id="1da0e-168">Cuando no hay problemas de conexión y la aplicación de `Stop` usuario finaliza la conexión de SignalR mediante una llamada al método, la conexión de SignalR y la conexión de transporte comienzan y terminan aproximadamente al mismo tiempo.</span><span class="sxs-lookup"><span data-stu-id="1da0e-168">When there are no connection problems, and the user application ends the SignalR connection by calling the `Stop` method, the SignalR connection and the transport connection begin and end at about the same time.</span></span> <span data-ttu-id="1da0e-169">En las secciones siguientes se describen con más detalle los demás escenarios.</span><span class="sxs-lookup"><span data-stu-id="1da0e-169">The following sections describe in more detail the other scenarios.</span></span>

<a id="transportdisconnect"></a>

### <a name="transport-disconnection-scenarios"></a><span data-ttu-id="1da0e-170">Escenarios de desconexión del transporte</span><span class="sxs-lookup"><span data-stu-id="1da0e-170">Transport disconnection scenarios</span></span>

<span data-ttu-id="1da0e-171">Las conexiones físicas pueden ser lentas o puede haber interrupciones en la conectividad.</span><span class="sxs-lookup"><span data-stu-id="1da0e-171">Physical connections might be slow or there might be interruptions in connectivity.</span></span> <span data-ttu-id="1da0e-172">Dependiendo de factores como la duración de la interrupción, la conexión de transporte puede descartarse.</span><span class="sxs-lookup"><span data-stu-id="1da0e-172">Depending on factors such as the length of the interruption, the transport connection might be dropped.</span></span> <span data-ttu-id="1da0e-173">SignalR entonces intenta restablecer la conexión de transporte.</span><span class="sxs-lookup"><span data-stu-id="1da0e-173">SignalR then tries to re-establish the transport connection.</span></span> <span data-ttu-id="1da0e-174">A veces, la API de conexión de transporte detecta la interrupción y elimina la conexión de transporte, y SignalR descubre inmediatamente que se pierde la conexión.</span><span class="sxs-lookup"><span data-stu-id="1da0e-174">Sometimes the transport connection API detects the interruption and drops the transport connection, and SignalR finds out immediately that the connection is lost.</span></span> <span data-ttu-id="1da0e-175">En otros escenarios, ni la API de conexión de transporte ni SignalR se da cuenta inmediatamente de que se ha perdido la conectividad.</span><span class="sxs-lookup"><span data-stu-id="1da0e-175">In other scenarios, neither the transport connection API nor SignalR becomes aware immediately that connectivity has been lost.</span></span> <span data-ttu-id="1da0e-176">Para todos los transportes excepto el sondeo largo, el cliente de SignalR utiliza una función llamada *keepalive* para comprobar la pérdida de conectividad que la API de transporte no puede detectar.</span><span class="sxs-lookup"><span data-stu-id="1da0e-176">For all transports except long polling, the SignalR client uses a function called *keepalive* to check for loss of connectivity that the transport API is unable to detect.</span></span> <span data-ttu-id="1da0e-177">Para obtener información acerca de las conexiones de sondeo largos, consulte Tiempo de espera y configuración de [keepalive](#timeoutkeepalive) más adelante en este tema.</span><span class="sxs-lookup"><span data-stu-id="1da0e-177">For information about long polling connections, see [Timeout and keepalive settings](#timeoutkeepalive) later in this topic.</span></span>

<span data-ttu-id="1da0e-178">Cuando una conexión está inactiva, periódicamente el servidor envía un paquete de keepalive al cliente.</span><span class="sxs-lookup"><span data-stu-id="1da0e-178">When a connection is inactive, periodically the server sends a keepalive packet to the client.</span></span> <span data-ttu-id="1da0e-179">A partir de la fecha en que se escribe este artículo, la frecuencia predeterminada es cada 10 segundos.</span><span class="sxs-lookup"><span data-stu-id="1da0e-179">As of the date this article is being written, the default frequency is every 10 seconds.</span></span> <span data-ttu-id="1da0e-180">Al escuchar estos paquetes, los clientes pueden decir si hay un problema de conexión.</span><span class="sxs-lookup"><span data-stu-id="1da0e-180">By listening for these packets, clients can tell if there is a connection problem.</span></span> <span data-ttu-id="1da0e-181">Si un paquete del keepalive no se recibe cuando se espera, después de un corto tiempo el cliente asume que hay problemas de conexión tales como lentitud o interrupciones.</span><span class="sxs-lookup"><span data-stu-id="1da0e-181">If a keepalive packet is not received when expected, after a short time the client assumes that there are connection problems such as slowness or interruptions.</span></span> <span data-ttu-id="1da0e-182">Si el keepalive todavía no se recibe después de un tiempo más largo, el cliente asume que la conexión se ha caído, y comienza a intentar volver a conectar.</span><span class="sxs-lookup"><span data-stu-id="1da0e-182">If the keepalive is still not received after a longer time, the client assumes that the connection has been dropped, and it begins trying to reconnect.</span></span>

<span data-ttu-id="1da0e-183">En el diagrama siguiente se muestran los eventos de cliente y servidor que se generan en un escenario típico cuando hay problemas con la conexión física que la API de transporte no reconoce inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="1da0e-183">The following diagram illustrates the client and server events that are raised in a typical scenario when there are problems with the physical connection that aren't immediately recognized by the transport API.</span></span> <span data-ttu-id="1da0e-184">El diagrama se aplica a las siguientes circunstancias:</span><span class="sxs-lookup"><span data-stu-id="1da0e-184">The diagram applies to the following circumstances:</span></span>

- <span data-ttu-id="1da0e-185">El transporte es WebSockets, marco para siempre o eventos enviados por el servidor.</span><span class="sxs-lookup"><span data-stu-id="1da0e-185">The transport is WebSockets, forever frame, or server-sent events.</span></span>
- <span data-ttu-id="1da0e-186">Hay diferentes períodos de interrupción en la conexión de red física.</span><span class="sxs-lookup"><span data-stu-id="1da0e-186">There are varying periods of interruption in the physical network connection.</span></span>
- <span data-ttu-id="1da0e-187">La API de transporte no se da cuenta de las interrupciones, por lo que SignalR se basa en la funcionalidad de keepalive para detectarlas.</span><span class="sxs-lookup"><span data-stu-id="1da0e-187">The transport API does not become aware of the interruptions, so SignalR relies on the keepalive functionality to detect them.</span></span>

![Desconexiones de transporte](handling-connection-lifetime-events/_static/image2.png)

<span data-ttu-id="1da0e-189">Si el cliente entra en modo de reconexión pero no puede establecer una conexión de transporte dentro del límite de tiempo de espera de desconexión, el servidor finaliza la conexión de SignalR.</span><span class="sxs-lookup"><span data-stu-id="1da0e-189">If the client goes into reconnecting mode but can't establish a transport connection within the disconnect timeout limit, the server terminates the SignalR connection.</span></span> <span data-ttu-id="1da0e-190">Cuando esto sucede, el servidor ejecuta `OnDisconnected` el método del concentrador y pone en cola un mensaje de desconexión para enviarlo al cliente en caso de que el cliente se administre conectarse más adelante.</span><span class="sxs-lookup"><span data-stu-id="1da0e-190">When that happens, the server executes the Hub's `OnDisconnected` method and queues up a disconnect message to send to the client in case the client manages to connect later.</span></span> <span data-ttu-id="1da0e-191">Si el cliente entonces vuelve a conectarse, `Stop` recibe el comando disconnect y llama al método.</span><span class="sxs-lookup"><span data-stu-id="1da0e-191">If the client then does reconnect, it receives the disconnect command and calls the `Stop` method.</span></span> <span data-ttu-id="1da0e-192">En este `OnReconnected` escenario, no se ejecuta cuando `OnDisconnected` el cliente se `Stop`vuelve a conectar y no se ejecuta cuando el cliente llama a .</span><span class="sxs-lookup"><span data-stu-id="1da0e-192">In this scenario, `OnReconnected` is not executed when the client reconnects, and `OnDisconnected` is not executed when the client calls `Stop`.</span></span> <span data-ttu-id="1da0e-193">En el diagrama siguiente se muestra este escenario.</span><span class="sxs-lookup"><span data-stu-id="1da0e-193">The following diagram illustrates this scenario.</span></span>

![Interrupciones de transporte - tiempo de espera del servidor](handling-connection-lifetime-events/_static/image3.png)

<span data-ttu-id="1da0e-195">Los eventos de duración de la conexión de SignalR que se pueden generar en el cliente son los siguientes:</span><span class="sxs-lookup"><span data-stu-id="1da0e-195">The SignalR connection lifetime events that may be raised on the client are the following:</span></span>

- <span data-ttu-id="1da0e-196">`ConnectionSlow`evento del cliente.</span><span class="sxs-lookup"><span data-stu-id="1da0e-196">`ConnectionSlow` client event.</span></span>

    <span data-ttu-id="1da0e-197">Se genera cuando una proporción preestablecida del período de tiempo de espera de keepalive ha pasado desde que se recibió el último mensaje o ping de keepalive.</span><span class="sxs-lookup"><span data-stu-id="1da0e-197">Raised when a preset proportion of the keepalive timeout period has passed since the last message or keepalive ping was received.</span></span> <span data-ttu-id="1da0e-198">El período de advertencia predeterminado del tiempo de espera de keepalive es 2/3 del tiempo de espera del keepalive.</span><span class="sxs-lookup"><span data-stu-id="1da0e-198">The default keepalive timeout warning period is 2/3 of the keepalive timeout.</span></span> <span data-ttu-id="1da0e-199">El tiempo de espera de keepalive es de 20 segundos, por lo que la advertencia se produce en unos 13 segundos.</span><span class="sxs-lookup"><span data-stu-id="1da0e-199">The keepalive timeout is 20 seconds, so the warning occurs at about 13 seconds.</span></span>

    <span data-ttu-id="1da0e-200">Por abandono, el servidor envía los pings del keepalive cada 10 segundos, y el cliente comprueba para los pings del keepalive sobre cada 2 segundos (un tercio de la diferencia entre el valor del tiempo de espera del keepalive y el valor de advertencia del tiempo de espera del keepalive).</span><span class="sxs-lookup"><span data-stu-id="1da0e-200">By default, the server sends keepalive pings every 10 seconds, and the client checks for keepalive pings about every 2 seconds (one third of the difference between the keepalive timeout value and the keepalive timeout warning value).</span></span>

    <span data-ttu-id="1da0e-201">Si la API de transporte tiene conocimiento de una desconexión, SignalR podría ser informado de la desconexión antes de que pase el período de advertencia de tiempo de espera de keepalive.</span><span class="sxs-lookup"><span data-stu-id="1da0e-201">If the transport API becomes aware of a disconnection, SignalR might be informed of the disconnection before the keepalive timeout warning period passes.</span></span> <span data-ttu-id="1da0e-202">En ese caso, el `ConnectionSlow` evento no se generaría y `Reconnecting` SignalR iría directamente al evento.</span><span class="sxs-lookup"><span data-stu-id="1da0e-202">In that case, the `ConnectionSlow` event would not be raised, and SignalR would go directly to the `Reconnecting` event.</span></span>
- <span data-ttu-id="1da0e-203">`Reconnecting`evento del cliente.</span><span class="sxs-lookup"><span data-stu-id="1da0e-203">`Reconnecting` client event.</span></span>

    <span data-ttu-id="1da0e-204">Se genera cuando (a) la API de transporte detecta que se ha perdido la conexión, o (b) el período de tiempo de espera de keepalive ha pasado desde que se recibió el último mensaje o ping de keepalive.</span><span class="sxs-lookup"><span data-stu-id="1da0e-204">Raised when (a) the transport API detects that the connection is lost, or (b) the keepalive timeout period has passed since the last message or keepalive ping was received.</span></span> <span data-ttu-id="1da0e-205">El código de cliente de SignalR comienza a intentar volver a conectarse.</span><span class="sxs-lookup"><span data-stu-id="1da0e-205">The SignalR client code begins trying to reconnect.</span></span> <span data-ttu-id="1da0e-206">Puede controlar este evento si desea que la aplicación realice alguna acción cuando se pierde una conexión de transporte.</span><span class="sxs-lookup"><span data-stu-id="1da0e-206">You can handle this event if you want your application to take some action when a transport connection is lost.</span></span> <span data-ttu-id="1da0e-207">El período de tiempo de espera de keepalive predeterminado es actualmente de 20 segundos.</span><span class="sxs-lookup"><span data-stu-id="1da0e-207">The default keepalive timeout period is currently 20 seconds.</span></span>

    <span data-ttu-id="1da0e-208">Si el código de cliente intenta llamar a un método Hub mientras SignalR está en modo de reconexión, SignalR intentará enviar el comando.</span><span class="sxs-lookup"><span data-stu-id="1da0e-208">If your client code tries to call a Hub method while SignalR is in reconnecting mode, SignalR will try to send the command.</span></span> <span data-ttu-id="1da0e-209">La mayoría de las veces, tales intentos fracasarán, pero en algunas circunstancias podrían tener éxito.</span><span class="sxs-lookup"><span data-stu-id="1da0e-209">Most of the time, such attempts will fail, but in some circumstances they might succeed.</span></span> <span data-ttu-id="1da0e-210">Para los eventos enviados por el servidor, la trama para siempre y los transportes de sondeo largo, SignalR utiliza dos canales de comunicación, uno que el cliente utiliza para enviar mensajes y otro que utiliza para recibir mensajes.</span><span class="sxs-lookup"><span data-stu-id="1da0e-210">For the server-sent events, forever frame, and long polling transports, SignalR uses two communication channels, one that the client uses to send messages and one that it uses to receive messages.</span></span> <span data-ttu-id="1da0e-211">El canal utilizado para recibir es el abierto permanentemente, y ese es el que se cierra cuando se interrumpe la conexión física.</span><span class="sxs-lookup"><span data-stu-id="1da0e-211">The channel used for receiving is the permanently open one, and that's the one that is closed when the physical connection is interrupted.</span></span> <span data-ttu-id="1da0e-212">El canal utilizado para enviar permanece disponible, por lo que si se restaura la conectividad física, una llamada de método de cliente a servidor podría tener éxito antes de que se restablezca el canal de recepción.</span><span class="sxs-lookup"><span data-stu-id="1da0e-212">The channel used for sending remains available, so if physical connectivity is restored, a method call from client to server might be successful before the receive channel is re-established.</span></span> <span data-ttu-id="1da0e-213">El valor devuelto no se recibiría hasta que SignalR vuelva a abrir el canal utilizado para la recepción.</span><span class="sxs-lookup"><span data-stu-id="1da0e-213">The return value would not be received until SignalR re-opens the channel used for receiving.</span></span>
- <span data-ttu-id="1da0e-214">`Reconnected`evento del cliente.</span><span class="sxs-lookup"><span data-stu-id="1da0e-214">`Reconnected` client event.</span></span>

    <span data-ttu-id="1da0e-215">Se genera cuando se restablece la conexión de transporte.</span><span class="sxs-lookup"><span data-stu-id="1da0e-215">Raised when the transport connection is reestablished.</span></span> <span data-ttu-id="1da0e-216">Se `OnReconnected` ejecuta el controlador de eventos en el concentrador.</span><span class="sxs-lookup"><span data-stu-id="1da0e-216">The `OnReconnected` event handler in the Hub executes.</span></span>
- <span data-ttu-id="1da0e-217">`Closed`evento de`disconnected` cliente (evento en JavaScript).</span><span class="sxs-lookup"><span data-stu-id="1da0e-217">`Closed` client event (`disconnected` event in JavaScript).</span></span>

    <span data-ttu-id="1da0e-218">Se genera cuando expira el período de tiempo de espera de desconexión mientras el código de cliente de SignalR intenta volver a conectarse después de perder la conexión de transporte.</span><span class="sxs-lookup"><span data-stu-id="1da0e-218">Raised when the disconnect timeout period expires while the SignalR client code is trying to reconnect after losing the transport connection.</span></span> <span data-ttu-id="1da0e-219">El tiempo de espera de desconexión predeterminado es de 30 segundos.</span><span class="sxs-lookup"><span data-stu-id="1da0e-219">The default disconnect timeout is 30 seconds.</span></span> <span data-ttu-id="1da0e-220">(Este evento también se produce cuando `Stop` finaliza la conexión porque se llama al método.)</span><span class="sxs-lookup"><span data-stu-id="1da0e-220">(This event is also raised when the connection ends because the `Stop` method is called.)</span></span>

<span data-ttu-id="1da0e-221">Las interrupciones de la conexión de transporte que no son detectadas por la API de transporte y no retrasan la recepción de pings de keepalive desde el servidor durante más tiempo que el período de advertencia de tiempo de espera de keepalive podrían no provocar ningún evento de duración de la conexión.</span><span class="sxs-lookup"><span data-stu-id="1da0e-221">Transport connection interruptions that are not detected by the transport API and don't delay the reception of keepalive pings from the server for longer than the keepalive timeout warning period might not cause any connection lifetime events to be raised.</span></span>

<span data-ttu-id="1da0e-222">Algunos entornos de red cierran deliberadamente las conexiones inactivas, y otra función de los paquetes de keepalive es ayudar a prevenir esto dejando que estas redes sepan que una conexión SignalR está en uso.</span><span class="sxs-lookup"><span data-stu-id="1da0e-222">Some network environments deliberately close idle connections, and another function of the keepalive packets is to help prevent this by letting these networks know that a SignalR connection is in use.</span></span> <span data-ttu-id="1da0e-223">En casos extremos, la frecuencia predeterminada de los ping de keepalive podría no ser suficiente para evitar las conexiones cerradas.</span><span class="sxs-lookup"><span data-stu-id="1da0e-223">In extreme cases the default frequency of keepalive pings might not be enough to prevent closed connections.</span></span> <span data-ttu-id="1da0e-224">En ese caso usted puede configurar los pings del keepalive para ser enviados más a menudo.</span><span class="sxs-lookup"><span data-stu-id="1da0e-224">In that case you can configure keepalive pings to be sent more often.</span></span> <span data-ttu-id="1da0e-225">Para obtener más información, consulte Tiempo de espera y configuración de [keepalive](#timeoutkeepalive) más adelante en este tema.</span><span class="sxs-lookup"><span data-stu-id="1da0e-225">For more information, see [Timeout and keepalive settings](#timeoutkeepalive) later in this topic.</span></span>

> [!NOTE]
>
> <span data-ttu-id="1da0e-226">**Importante**: La secuencia de eventos descrita aquí no está garantizada.</span><span class="sxs-lookup"><span data-stu-id="1da0e-226">**Important**: The sequence of events described here is not guaranteed.</span></span> <span data-ttu-id="1da0e-227">SignalR realiza todos los intentos de generar eventos de duración de la conexión de una manera predecible de acuerdo con este esquema, pero hay muchas variaciones de eventos de red y muchas maneras en que los marcos de comunicaciones subyacentes, como las API de transporte, los controlan.</span><span class="sxs-lookup"><span data-stu-id="1da0e-227">SignalR makes every attempt to raise connection lifetime events in a predictable manner according to this scheme, but there are many variations of network events and many ways in which underlying communications frameworks such as transport APIs handle them.</span></span> <span data-ttu-id="1da0e-228">Por ejemplo, `Reconnected` es posible que el evento no se `OnConnected` genere cuando el cliente se vuelva a conectar o que el controlador del servidor se ejecute cuando el intento de establecer una conexión no se realice correctamente.</span><span class="sxs-lookup"><span data-stu-id="1da0e-228">For example, the `Reconnected` event might not be raised when the client reconnects, or the `OnConnected` handler on the server might run when the attempt to establish a connection is unsuccessful.</span></span> <span data-ttu-id="1da0e-229">En este tema se describen solo los efectos que normalmente se producirían en determinadas circunstancias típicas.</span><span class="sxs-lookup"><span data-stu-id="1da0e-229">This topic describes only the effects that would normally be produced by certain typical circumstances.</span></span>

<a id="clientdisconnect"></a>

### <a name="client-disconnection-scenarios"></a><span data-ttu-id="1da0e-230">Escenarios de desconexión del cliente</span><span class="sxs-lookup"><span data-stu-id="1da0e-230">Client disconnection scenarios</span></span>

<span data-ttu-id="1da0e-231">En un cliente de explorador, el código de cliente de SignalR que mantiene una conexión de SignalR se ejecuta en el contexto de JavaScript de una página web.</span><span class="sxs-lookup"><span data-stu-id="1da0e-231">In a browser client, the SignalR client code that maintains a SignalR connection runs in the JavaScript context of a web page.</span></span> <span data-ttu-id="1da0e-232">Es por eso que la conexión de SignalR tiene que finalizar cuando navega de una página a otra, y es por eso que tiene varias conexiones con varios iDs de conexión si se conecta desde varias ventanas o pestañas del explorador.</span><span class="sxs-lookup"><span data-stu-id="1da0e-232">That's why the SignalR connection has to end when you navigate from one page to another, and that's why you have multiple connections with multiple connection IDs if you connect from multiple browser windows or tabs.</span></span> <span data-ttu-id="1da0e-233">Cuando el usuario cierra una ventana o pestaña del explorador, o navega a una nueva página o actualiza la página, la `Stop` conexión de SignalR finaliza inmediatamente porque el código de cliente de SignalR controla ese evento de explorador y llama al método.</span><span class="sxs-lookup"><span data-stu-id="1da0e-233">When the user closes a browser window or tab, or navigates to a new page or refreshes the page, the SignalR connection immediately ends because SignalR client code handles that browser event for you and calls the `Stop` method.</span></span> <span data-ttu-id="1da0e-234">En estos escenarios, o en cualquier plataforma `Stop` cliente `OnDisconnected` cuando la aplicación llama al método, el `Closed` controlador de eventos `disconnected` se ejecuta inmediatamente en el servidor y el cliente genera el evento (el evento se denomina en JavaScript).</span><span class="sxs-lookup"><span data-stu-id="1da0e-234">In these scenarios, or in any client platform when your application calls the `Stop` method, the `OnDisconnected` event handler executes immediately on the server and the client raises the `Closed` event (the event is named `disconnected` in JavaScript).</span></span>

<span data-ttu-id="1da0e-235">Si una aplicación cliente o el equipo que se está ejecutando en caso de bloqueo o se queda en reposo (por ejemplo, cuando el usuario cierra el equipo portátil), el servidor no se informa sobre lo que sucedió.</span><span class="sxs-lookup"><span data-stu-id="1da0e-235">If a client application or the computer that it's running on crashes or goes to sleep (for example, when the user closes the laptop), the server is not informed about what happened.</span></span> <span data-ttu-id="1da0e-236">Por lo que el servidor sabe, la pérdida del cliente pudo deberse a la interrupción de la conectividad y el cliente podría estar intentando volver a conectarse.</span><span class="sxs-lookup"><span data-stu-id="1da0e-236">As far as the server knows, the loss of the client might be due to connectivity interruption and the client might be trying to reconnect.</span></span> <span data-ttu-id="1da0e-237">Por lo tanto, en estos escenarios el servidor espera para `OnDisconnected` dar al cliente la oportunidad de volver a conectarse y no se ejecuta hasta que expire el período de tiempo de espera de desconexión (alrededor de 30 segundos de forma predeterminada).</span><span class="sxs-lookup"><span data-stu-id="1da0e-237">Therefore, in these scenarios the server waits to give the client a chance to reconnect, and `OnDisconnected` does not execute until the disconnect timeout period expires (about 30 seconds by default).</span></span> <span data-ttu-id="1da0e-238">En el diagrama siguiente se muestra este escenario.</span><span class="sxs-lookup"><span data-stu-id="1da0e-238">The following diagram illustrates this scenario.</span></span>

![Fallo del equipo cliente](handling-connection-lifetime-events/_static/image4.png)

<a id="serverdisconnect"></a>

### <a name="server-disconnection-scenarios"></a><span data-ttu-id="1da0e-240">Escenarios de desconexión del servidor</span><span class="sxs-lookup"><span data-stu-id="1da0e-240">Server disconnection scenarios</span></span>

<span data-ttu-id="1da0e-241">Cuando un servidor se desconecta (se reinicia, se produce un error, el dominio de la aplicación se recicla, etc.), el resultado puede ser similar a una `ConnectionSlow` conexión perdida, o la API de transporte y SignalR podrían saber inmediatamente que el servidor se ha ido y SignalR podría comenzar a intentar volver a conectarse sin provocar el evento.</span><span class="sxs-lookup"><span data-stu-id="1da0e-241">When a server goes offline -- it reboots, fails, the app domain recycles, etc. -- the result might be similar to a lost connection, or the transport API and SignalR might know immediately that the server is gone, and SignalR might begin trying to reconnect without raising the `ConnectionSlow` event.</span></span> <span data-ttu-id="1da0e-242">Si el cliente entra en modo de reconexión, y si el servidor se recupera o se reinicia o se pone en línea un nuevo servidor antes de que expire el período de tiempo de espera de desconexión, el cliente volverá a conectarse al servidor restaurado o nuevo.</span><span class="sxs-lookup"><span data-stu-id="1da0e-242">If the client goes into reconnecting mode, and if the server recovers or restarts or a new server is brought online before the disconnect timeout period expires, the client will reconnect to the restored or new server.</span></span> <span data-ttu-id="1da0e-243">En ese caso, la conexión de SignalR `Reconnected` continúa en el cliente y se genera el evento.</span><span class="sxs-lookup"><span data-stu-id="1da0e-243">In that case, the SignalR connection continues on the client and the `Reconnected` event is raised.</span></span> <span data-ttu-id="1da0e-244">En el primer `OnDisconnected` servidor, nunca se ejecuta, y en el nuevo servidor, `OnReconnected` se ejecuta aunque `OnConnected` nunca se ejecutó para ese cliente en ese servidor antes.</span><span class="sxs-lookup"><span data-stu-id="1da0e-244">On the first server, `OnDisconnected` is never executed, and on the new server, `OnReconnected` is executed although `OnConnected` was never executed for that client on that server before.</span></span> <span data-ttu-id="1da0e-245">(El efecto es el mismo si el cliente se vuelve a conectar al mismo servidor después de un reinicio o reciclaje de dominio de aplicación, porque cuando el servidor se reinicia no tiene memoria de actividad de conexión anterior.) En el diagrama siguiente se supone que la API de `ConnectionSlow` transporte tiene conocimiento de la conexión perdida inmediatamente, por lo que no se genera el evento.</span><span class="sxs-lookup"><span data-stu-id="1da0e-245">(The effect is the same if the client reconnects to the same server after a reboot or app domain recycle, because when the server restarts it has no memory of prior connection activity.) The following diagram assumes that the transport API becomes aware of the lost connection immediately, so the `ConnectionSlow` event is not raised.</span></span>

![Error del servidor y reconexión](handling-connection-lifetime-events/_static/image5.png)

<span data-ttu-id="1da0e-247">Si un servidor no está disponible dentro del período de tiempo de espera de desconexión, finaliza la conexión de SignalR.</span><span class="sxs-lookup"><span data-stu-id="1da0e-247">If a server does not become available within the disconnect timeout period, the SignalR connection ends.</span></span> <span data-ttu-id="1da0e-248">En este escenario, `Closed` `disconnected` el evento (en clientes JavaScript) se genera en el cliente, pero `OnDisconnected` nunca se llama en el servidor.</span><span class="sxs-lookup"><span data-stu-id="1da0e-248">In this scenario, the `Closed` event (`disconnected` in JavaScript clients) is raised on the client but `OnDisconnected` is never called on the server.</span></span> <span data-ttu-id="1da0e-249">En el diagrama siguiente se supone que la API de transporte no tiene conocimiento de la `ConnectionSlow` conexión perdida, por lo que se detecta mediante la funcionalidad de keepalive de SignalR y se genera el evento.</span><span class="sxs-lookup"><span data-stu-id="1da0e-249">The following diagram assumes that the transport API does not become aware of the lost connection, so it is detected by SignalR keepalive functionality and the `ConnectionSlow` event is raised.</span></span>

![Error y tiempo de espera del servidor](handling-connection-lifetime-events/_static/image6.png)

<a id="timeoutkeepalive"></a>

## <a name="timeout-and-keepalive-settings"></a><span data-ttu-id="1da0e-251">Tiempo de espera y ajustes de keepalive</span><span class="sxs-lookup"><span data-stu-id="1da0e-251">Timeout and keepalive settings</span></span>

<span data-ttu-id="1da0e-252">El `ConnectionTimeout`valor `DisconnectTimeout`predeterminado `KeepAlive` , , y los valores son adecuados para la mayoría de los escenarios, pero se pueden cambiar si el entorno tiene necesidades especiales.</span><span class="sxs-lookup"><span data-stu-id="1da0e-252">The default `ConnectionTimeout`, `DisconnectTimeout`, and `KeepAlive` values are appropriate for most scenarios but can be changed if your environment has special needs.</span></span> <span data-ttu-id="1da0e-253">Por ejemplo, si el entorno de red cierra las conexiones que están inactivas durante 5 segundos, es posible que tenga que disminuir el valor de keepalive.</span><span class="sxs-lookup"><span data-stu-id="1da0e-253">For example, if your network environment closes connections that are idle for 5 seconds, you might have to decrease the keepalive value.</span></span>

<a id="connectiontimeout"></a>

### <a name="connectiontimeout"></a><span data-ttu-id="1da0e-254">ConnectionTimeout</span><span class="sxs-lookup"><span data-stu-id="1da0e-254">ConnectionTimeout</span></span>

<span data-ttu-id="1da0e-255">Esta configuración representa la cantidad de tiempo para dejar una conexión de transporte abierta y esperar una respuesta antes de cerrarla y abrir una nueva conexión.</span><span class="sxs-lookup"><span data-stu-id="1da0e-255">This setting represents the amount of time to leave a transport connection open and waiting for a response before closing it and opening a new connection.</span></span> <span data-ttu-id="1da0e-256">El valor predeterminado es 110 segundos.</span><span class="sxs-lookup"><span data-stu-id="1da0e-256">The default value is 110 seconds.</span></span>

<span data-ttu-id="1da0e-257">Esta configuración solo se aplica cuando se deshabilita la funcionalidad keepalive, que normalmente solo se aplica al transporte de sondeo largo.</span><span class="sxs-lookup"><span data-stu-id="1da0e-257">This setting applies only when keepalive functionality is disabled, which normally applies only to the long polling transport.</span></span> <span data-ttu-id="1da0e-258">El diagrama siguiente ilustra el efecto de esta configuración en una conexión de transporte de sondeo largo.</span><span class="sxs-lookup"><span data-stu-id="1da0e-258">The following diagram illustrates the effect of this setting on a long polling transport connection.</span></span>

![Larga conexión de transporte de sondeo](handling-connection-lifetime-events/_static/image7.png)

<a id="disconnecttimeout"></a>

### <a name="disconnecttimeout"></a><span data-ttu-id="1da0e-260">DisconnectTimeout</span><span class="sxs-lookup"><span data-stu-id="1da0e-260">DisconnectTimeout</span></span>

<span data-ttu-id="1da0e-261">Esta configuración representa la cantidad de tiempo que se debe `Disconnected` esperar después de que se pierda una conexión de transporte antes de generar el evento.</span><span class="sxs-lookup"><span data-stu-id="1da0e-261">This setting represents the amount of time to wait after a transport connection is lost before raising the `Disconnected` event.</span></span> <span data-ttu-id="1da0e-262">El valor predeterminado es 30 segundos.</span><span class="sxs-lookup"><span data-stu-id="1da0e-262">The default value is 30 seconds.</span></span> <span data-ttu-id="1da0e-263">Cuando se `DisconnectTimeout` `KeepAlive` establece , se establece automáticamente `DisconnectTimeout` en 1/3 del valor.</span><span class="sxs-lookup"><span data-stu-id="1da0e-263">When you set `DisconnectTimeout`, `KeepAlive` is automatically set to 1/3 of the `DisconnectTimeout` value.</span></span>

<a id="keepalive"></a>

### <a name="keepalive"></a><span data-ttu-id="1da0e-264">KeepAlive</span><span class="sxs-lookup"><span data-stu-id="1da0e-264">KeepAlive</span></span>

<span data-ttu-id="1da0e-265">Esta configuración representa la cantidad de tiempo que hay que esperar antes de enviar un paquete de keepalive a través de una conexión inactiva.</span><span class="sxs-lookup"><span data-stu-id="1da0e-265">This setting represents the amount of time to wait before sending a keepalive packet over an idle connection.</span></span> <span data-ttu-id="1da0e-266">El valor predeterminado es 10 segundos.</span><span class="sxs-lookup"><span data-stu-id="1da0e-266">The default value is 10 seconds.</span></span> <span data-ttu-id="1da0e-267">Este valor no debe ser superior `DisconnectTimeout` a 1/3 del valor.</span><span class="sxs-lookup"><span data-stu-id="1da0e-267">This value must not be more than 1/3 of the `DisconnectTimeout` value.</span></span>

<span data-ttu-id="1da0e-268">Si desea establecer `DisconnectTimeout` ambos `KeepAlive`y `KeepAlive` `DisconnectTimeout`, establecer después de .</span><span class="sxs-lookup"><span data-stu-id="1da0e-268">If you want to set both `DisconnectTimeout` and `KeepAlive`, set `KeepAlive` after `DisconnectTimeout`.</span></span> <span data-ttu-id="1da0e-269">De `KeepAlive` lo contrario, la `DisconnectTimeout` configuración `KeepAlive` se sobrescribirá cuando se establezca automáticamente en 1/3 del valor de tiempo de espera.</span><span class="sxs-lookup"><span data-stu-id="1da0e-269">Otherwise your `KeepAlive` setting will be overwritten when `DisconnectTimeout` automatically sets `KeepAlive` to 1/3 of the timeout value.</span></span>

<span data-ttu-id="1da0e-270">Si desea deshabilitar la funcionalidad keepalive, establezca en `KeepAlive` null.</span><span class="sxs-lookup"><span data-stu-id="1da0e-270">If you want to disable keepalive functionality, set `KeepAlive` to null.</span></span> <span data-ttu-id="1da0e-271">La funcionalidad Keepalive se deshabilita automáticamente para el transporte de sondeo largo.</span><span class="sxs-lookup"><span data-stu-id="1da0e-271">Keepalive functionality is automatically disabled for the long polling transport.</span></span>

<a id="changetimeout"></a>

### <a name="how-to-change-timeout-and-keepalive-settings"></a><span data-ttu-id="1da0e-272">Cómo cambiar el tiempo de espera y la configuración de keepalive</span><span class="sxs-lookup"><span data-stu-id="1da0e-272">How to change timeout and keepalive settings</span></span>

<span data-ttu-id="1da0e-273">Para cambiar los valores predeterminados de `Application_Start` esta configuración, establézcalos en el archivo *Global.asax,* como se muestra en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="1da0e-273">To change the default values for these settings, set them in `Application_Start` in your *Global.asax* file, as shown in the following example.</span></span> <span data-ttu-id="1da0e-274">Los valores que se muestran en el código de ejemplo son los mismos que los valores predeterminados.</span><span class="sxs-lookup"><span data-stu-id="1da0e-274">The values shown in the sample code are the same as the default values.</span></span>

[!code-csharp[Main](handling-connection-lifetime-events/samples/sample1.cs)]

<a id="notifydisconnect"></a>

## <a name="how-to-notify-the-user-about-disconnections"></a><span data-ttu-id="1da0e-275">Cómo notificar al usuario sobre desconexiones</span><span class="sxs-lookup"><span data-stu-id="1da0e-275">How to notify the user about disconnections</span></span>

<span data-ttu-id="1da0e-276">En algunas aplicaciones es posible que desee mostrar un mensaje al usuario cuando hay problemas de conectividad.</span><span class="sxs-lookup"><span data-stu-id="1da0e-276">In some applications you might want to display a message to the user when there are connectivity problems.</span></span> <span data-ttu-id="1da0e-277">Tiene varias opciones para cómo y cuándo hacer esto.</span><span class="sxs-lookup"><span data-stu-id="1da0e-277">You have several options for how and when to do this.</span></span> <span data-ttu-id="1da0e-278">Los siguientes ejemplos de código son para un cliente JavaScript que usa el proxy generado.</span><span class="sxs-lookup"><span data-stu-id="1da0e-278">The following code samples are for a JavaScript client using the generated proxy.</span></span>

- <span data-ttu-id="1da0e-279">Controle `connectionSlow` el evento para mostrar un mensaje tan pronto como SignalR sea consciente de los problemas de conexión, antes de que entre en modo de reconexión.</span><span class="sxs-lookup"><span data-stu-id="1da0e-279">Handle the `connectionSlow` event to display a message as soon as SignalR is aware of connection problems, before it goes into reconnecting mode.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample2.js)]
- <span data-ttu-id="1da0e-280">Controlar `reconnecting` el evento para mostrar un mensaje cuando SignalR es consciente de una desconexión y está entrando en modo de reconexión.</span><span class="sxs-lookup"><span data-stu-id="1da0e-280">Handle the `reconnecting` event to display a message when SignalR is aware of a disconnection and is going into reconnecting mode.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample3.js)]
- <span data-ttu-id="1da0e-281">Controle `disconnected` el evento para mostrar un mensaje cuando se ha agotado el tiempo de espera de un intento de volver a conectarse. En este escenario, la única manera de restablecer una conexión con el servidor `Start` de nuevo es reiniciar la conexión de SignalR llamando al método, que creará un nuevo identificador de conexión.</span><span class="sxs-lookup"><span data-stu-id="1da0e-281">Handle the `disconnected` event to display a message when an attempt to reconnect has timed out. In this scenario, the only way to re-establish a connection with the server again is to restart the SignalR connection by calling the `Start` method, which will create a new connection ID.</span></span> <span data-ttu-id="1da0e-282">En el ejemplo de código siguiente se usa una marca para asegurarse de que emite la notificación `Stop` solo después de un tiempo de espera de reconexión, no después de un final normal a la conexión de SignalR causada por una llamada al método.</span><span class="sxs-lookup"><span data-stu-id="1da0e-282">The following code sample uses a flag to make sure that you issue the notification only after a reconnecting timeout, not after a normal end to the SignalR connection caused by calling the `Stop` method.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample4.js)]

<a id="continuousreconnect"></a>

## <a name="how-to-continuously-reconnect"></a><span data-ttu-id="1da0e-283">Cómo volver a conectarse continuamente</span><span class="sxs-lookup"><span data-stu-id="1da0e-283">How to continuously reconnect</span></span>

<span data-ttu-id="1da0e-284">En algunas aplicaciones es posible que desee restablecer automáticamente una conexión después de que se ha perdido y se ha agotado el tiempo de espera del intento de volver a conectarse. Para ello, puede llamar `Start` al `Closed` método desde`disconnected` el controlador de eventos (controlador de eventos en clientes JavaScript).</span><span class="sxs-lookup"><span data-stu-id="1da0e-284">In some applications you might want to automatically re-establish a connection after it has been lost and the attempt to reconnect has timed out. To do that, you can call the `Start` method from your `Closed` event handler (`disconnected` event handler on JavaScript clients).</span></span> <span data-ttu-id="1da0e-285">Es posible que desee esperar `Start` un período de tiempo antes de llamar para evitar hacer esto con demasiada frecuencia cuando el servidor o la conexión física no están disponibles.</span><span class="sxs-lookup"><span data-stu-id="1da0e-285">You might want to wait a period of time before calling `Start` in order to avoid doing this too frequently when the server or the physical connection are unavailable.</span></span> <span data-ttu-id="1da0e-286">El ejemplo de código siguiente es para un cliente JavaScript que usa el proxy generado.</span><span class="sxs-lookup"><span data-stu-id="1da0e-286">The following code sample is for a JavaScript client using the generated proxy.</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample5.js)]

<span data-ttu-id="1da0e-287">Un problema potencial a tener en cuenta en los clientes móviles es que los intentos de reconexión continua cuando el servidor o la conexión física no está disponible podrían causar un agotamiento innecesario de la batería.</span><span class="sxs-lookup"><span data-stu-id="1da0e-287">A potential problem to be aware of in mobile clients is that continuous reconnection attempts when the server or physical connection isn't available could cause unnecessary battery drain.</span></span>

<a id="disconnectclientfromserver"></a>

## <a name="how-to-disconnect-a-client-in-server-code"></a><span data-ttu-id="1da0e-288">Cómo desconectar un cliente en el código del servidor</span><span class="sxs-lookup"><span data-stu-id="1da0e-288">How to disconnect a client in server code</span></span>

<span data-ttu-id="1da0e-289">SignalR versión 2 no tiene una API de servidor integrada para desconectar clientes.</span><span class="sxs-lookup"><span data-stu-id="1da0e-289">SignalR version 2 does not have a built-in server API for disconnecting clients.</span></span> <span data-ttu-id="1da0e-290">Hay [planes para agregar esta funcionalidad en el futuro.](https://github.com/SignalR/SignalR/issues/2101)</span><span class="sxs-lookup"><span data-stu-id="1da0e-290">There are [plans for adding this functionality in the future](https://github.com/SignalR/SignalR/issues/2101).</span></span> <span data-ttu-id="1da0e-291">En la versión actual de SignalR, la forma más sencilla de desconectar un cliente del servidor es implementar un método de desconexión en el cliente y llamar a ese método desde el servidor.</span><span class="sxs-lookup"><span data-stu-id="1da0e-291">In the current SignalR release, the simplest way to disconnect a client from the server is to implement a disconnect method on the client and call that method from the server.</span></span> <span data-ttu-id="1da0e-292">En el ejemplo de código siguiente se muestra un método de desconexión para un cliente JavaScript mediante el proxy generado.</span><span class="sxs-lookup"><span data-stu-id="1da0e-292">The following code sample shows a disconnect method for a JavaScript client using the generated proxy.</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample6.js)]

> [!WARNING]
> <span data-ttu-id="1da0e-293">Seguridad: ni este método para desconectar clientes ni la API integrada propuesta abordarán el escenario de los clientes hackeados `stopClient` que ejecutan código malintencionado, ya que los clientes podrían volver a conectarse o el código hackeado podría eliminar el método o cambiar lo que hace.</span><span class="sxs-lookup"><span data-stu-id="1da0e-293">Security - Neither this method for disconnecting clients nor the proposed built-in API will address the scenario of hacked clients that are running malicious code, since the clients could reconnect or the hacked code might remove the `stopClient` method or change what it does.</span></span> <span data-ttu-id="1da0e-294">El lugar adecuado para implementar la protección de denegación de servicio (DOS) con estado no está en el marco de trabajo o la capa de servidor, sino en la infraestructura de front-end.</span><span class="sxs-lookup"><span data-stu-id="1da0e-294">The appropriate place to implement stateful denial-of-service (DOS) protection is not in the framework or the server layer, but rather in front-end infrastructure.</span></span>

<a id="detectingreasonfordisconnection"></a>
## <a name="detecting-the-reason-for-a-disconnection"></a><span data-ttu-id="1da0e-295">Detectar la razón de una desconexión</span><span class="sxs-lookup"><span data-stu-id="1da0e-295">Detecting the reason for a disconnection</span></span>

<span data-ttu-id="1da0e-296">SignalR 2.1 agrega una sobrecarga `OnDisconnect` al evento de servidor que indica si el cliente se desconectó deliberadamente en lugar de agotar el tiempo de espera. El `StopCalled` parámetro es true si el cliente cerró explícitamente la conexión.</span><span class="sxs-lookup"><span data-stu-id="1da0e-296">SignalR 2.1 adds an overload to the server `OnDisconnect` event that indicates if the client deliberately disconnected rather than timing out. The `StopCalled` parameter is true if the client explicitly closed the connection.</span></span> <span data-ttu-id="1da0e-297">En JavaScript, si un error de servidor llevó al cliente a `$.connection.hub.lastError`desconectarse, la información de error se pasará al cliente como .</span><span class="sxs-lookup"><span data-stu-id="1da0e-297">In JavaScript, if a server error led the client to disconnect, the error information will be passed to the client as `$.connection.hub.lastError`.</span></span>

<span data-ttu-id="1da0e-298">**Código de servidor `stopCalled` de C-: parámetro**</span><span class="sxs-lookup"><span data-stu-id="1da0e-298">**C# server code: `stopCalled` parameter**</span></span>

[!code-csharp[Main](handling-connection-lifetime-events/samples/sample7.cs?highlight=1,3)]

<span data-ttu-id="1da0e-299">**Código de cliente `lastError` JavaScript: acceso en caso de `disconnect` evento.**</span><span class="sxs-lookup"><span data-stu-id="1da0e-299">**JavaScript client code: accessing `lastError` in the `disconnect` event.**</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample8.js?highlight=2-3)]
